{
  "component:pwc_header": {
    "updateTime": 1767074652432,
    "name": "pwc-header",
    "apiName": "pwc_header__c",
    "content": "",
    "bindingObjectApiName": "NONE",
    "type": "component",
    "nameSpace": "",
    "returnType": "",
    "tenantId": "",
    "lang": 0
  },
  "component:firstComponents": {
    "updateTime": 1767074652954,
    "name": "firstComponents",
    "apiName": "firstComponents__c",
    "content": "",
    "bindingObjectApiName": "NONE",
    "type": "component",
    "nameSpace": "",
    "returnType": "",
    "tenantId": "",
    "lang": 0
  },
  "component:TestSuccessComponent": {
    "updateTime": 1767074653477,
    "name": "TestSuccessComponent",
    "apiName": "TestSuccessComponent__c",
    "content": "",
    "bindingObjectApiName": "NONE",
    "type": "component",
    "nameSpace": "",
    "returnType": "",
    "tenantId": "",
    "lang": 0
  },
  "component:TestNewComponent3": {
    "updateTime": 1767074653989,
    "name": "TestNewComponent3",
    "apiName": "TestNewComponent3__c",
    "content": "",
    "bindingObjectApiName": "NONE",
    "type": "component",
    "nameSpace": "",
    "returnType": "",
    "tenantId": "",
    "lang": 0
  },
  "component:TestNewComponent2": {
    "updateTime": 1767074654505,
    "name": "TestNewComponent2",
    "apiName": "TestNewComponent2__c",
    "content": "",
    "bindingObjectApiName": "NONE",
    "type": "component",
    "nameSpace": "",
    "returnType": "",
    "tenantId": "",
    "lang": 0
  },
  "component:TestNewComponent": {
    "updateTime": 1767074655020,
    "name": "TestNewComponent",
    "apiName": "TestNewComponent__c",
    "content": "",
    "bindingObjectApiName": "NONE",
    "type": "component",
    "nameSpace": "",
    "returnType": "",
    "tenantId": "",
    "lang": 0
  },
  "component:TestCreateComponent": {
    "updateTime": 1767074655527,
    "name": "TestCreateComponent",
    "apiName": "TestCreateComponent__c",
    "content": "",
    "bindingObjectApiName": "NONE",
    "type": "component",
    "nameSpace": "",
    "returnType": "",
    "tenantId": "",
    "lang": 0
  },
  "component:TestComponent": {
    "updateTime": 1767074655528,
    "name": "TestComponent",
    "apiName": "TestComponent",
    "content": "",
    "bindingObjectApiName": "NONE",
    "type": "component",
    "nameSpace": "",
    "returnType": "",
    "tenantId": "",
    "lang": 0
  },
  "component:NewAgainComponent": {
    "updateTime": 1767074656038,
    "name": "NewAgainComponent",
    "apiName": "NewAgainComponent__c",
    "content": "",
    "bindingObjectApiName": "NONE",
    "type": "component",
    "nameSpace": "",
    "returnType": "",
    "tenantId": "",
    "lang": 0
  },
  "component:MyVueComponent": {
    "updateTime": 1767074656547,
    "name": "MyVueComponent",
    "apiName": "MyVueComponent__c",
    "content": "",
    "bindingObjectApiName": "NONE",
    "type": "component",
    "nameSpace": "",
    "returnType": "",
    "tenantId": "",
    "lang": 0
  },
  "component:MyAgainComponent": {
    "updateTime": 1767074657084,
    "name": "MyAgainComponent",
    "apiName": "MyAgainComponent__c",
    "content": "",
    "bindingObjectApiName": "NONE",
    "type": "component",
    "nameSpace": "",
    "returnType": "",
    "tenantId": "",
    "lang": 0
  },
  "component:My_Test_Component": {
    "updateTime": 1767074657087,
    "name": "My-Test-Component",
    "apiName": "My_Test_Component__c",
    "content": "",
    "bindingObjectApiName": "NONE",
    "type": "component",
    "nameSpace": "",
    "returnType": "",
    "tenantId": "",
    "lang": 0
  },
  "component:ESign_Button": {
    "updateTime": 1767074657648,
    "name": "ESign Button",
    "apiName": "ESign_Button__c",
    "content": "",
    "bindingObjectApiName": "NONE",
    "type": "component",
    "nameSpace": "",
    "returnType": "",
    "tenantId": "",
    "lang": 0
  },
  "component:ButtonComponent": {
    "updateTime": 1767074660041,
    "name": "ButtonComponent",
    "apiName": "ButtonComponent",
    "content": "",
    "bindingObjectApiName": "NONE",
    "type": "component",
    "nameSpace": "",
    "returnType": "",
    "tenantId": "",
    "lang": 0
  },
  "component:Again2Component": {
    "updateTime": 1767074659424,
    "name": "Again2Component",
    "apiName": "Again2Component__c",
    "content": "",
    "bindingObjectApiName": "NONE",
    "type": "component",
    "nameSpace": "",
    "returnType": "",
    "tenantId": "",
    "lang": 0
  },
  "component:ESignButton": {
    "updateTime": 1767074660573,
    "name": "ESign Button",
    "apiName": "ESignButton__c",
    "content": "",
    "bindingObjectApiName": "NONE",
    "type": "component",
    "nameSpace": "",
    "returnType": "",
    "tenantId": "",
    "lang": 0
  },
  "component:firstComponent": {
    "updateTime": 1767074661160,
    "name": "firstComponents",
    "apiName": "firstComponent__c",
    "content": "",
    "bindingObjectApiName": "NONE",
    "type": "component",
    "nameSpace": "",
    "returnType": "",
    "tenantId": "",
    "lang": 0
  },
  "plugin:MyVuePlugin": {
    "updateTime": 1767074662224,
    "name": "MyVuePlugin",
    "apiName": "MyVuePlugin__c",
    "content": "",
    "bindingObjectApiName": "NONE",
    "type": "plugin",
    "nameSpace": "",
    "returnType": "",
    "tenantId": "",
    "lang": 0
  },
  "plugin:MyPlugin": {
    "updateTime": 1767074662958,
    "name": "MyPlugin",
    "apiName": "MyPlugin__c",
    "content": "",
    "bindingObjectApiName": "NONE",
    "type": "plugin",
    "nameSpace": "",
    "returnType": "",
    "tenantId": "",
    "lang": 0
  },
  "plugin:pluginNirnn": {
    "updateTime": 1767074663539,
    "name": "MyPlugin",
    "apiName": "pluginNirnn__c",
    "content": "",
    "bindingObjectApiName": "NONE",
    "type": "plugin",
    "nameSpace": "",
    "returnType": "",
    "tenantId": "",
    "lang": 0
  },
  "function:generateWebhookUrl": {
    "updateTime": 1767074664249,
    "name": "Generate Webhook Url",
    "apiName": "generateWebhookUrl__c",
    "content": "/**\n * @author 彭黄振Jame\n * @codeName Generate Webhook Url\n * @description Generate Webhook Url\n * @createTime 2025-10-15\n * @bindingObjectLabel Webhook URL\n * @bindingObjectApiName WebhookURL__c\n * @函数需求编号\n */\nString apiName = context.data.object_describe_api_name as String;\n\nString baseUrl = \"https://www.kitdoll.com\"; \nString instanceURL = \"https://www.fxiaoke.com\";\nString saveToken2GateUrl = \"https://www.kitdoll.com/admin/token\"\n\nString certification = context.data.certification__c as String;\nString keyId = context.data._id as String;\nString webhookUrl = \"\"\nString methodCls = context.data.webhookMethods__c as String;\nString webhookToken = \"\"\nString dataToken = context.data.token__c as String\nif (dataToken == null){\n  if (certification != null && webhookToken != null) {\n    String tokenBody1 = '{\"method\":'+methodCls+',\"baseurl\":'+instanceURL+',\"cert\" :' +certification+'}' \n    webhookToken = Fx.crypto.MD5.encode(tokenBody1) as String\n    // String tokenBody = '{\"token\":'+webhookToken+',\"method\":'+methodCls+',\"baseurl\":'+baseUrl+',\"cert\" :' +certification+'}' \n    webhookUrl = baseUrl + \"/webhook/\" + webhookToken;\n    log.info(\"webhookurl: \"+ webhookUrl)\n  } else {\n    log.info(\"Certification is null, cannot generate token.\")\n  }\n  \n  // 保存到网关的请求体\n  Map map = [\"token\": webhookToken, \"method\": methodCls,\"baseurl\": instanceURL,\"cert\":certification]\n  StringBody body = StringBody.builder().content(map).build()\n  \n  Request request = Request.builder()\n                  .method(\"POST\")\n                  .url(saveToken2GateUrl)\n                  .timeout(7000)\n                  .retryCount(0)\n                  .header(\"Content-Type\", \"application/json\")\n                  .body(body)\n                  .build()\n  def(Boolean error, HttpResult result, String message) = Fx.http.execute(request)\n          \n  if (error || result.statusCode != 200){\n    log.error(\"http request error01: \"+ error +\" errorMessage: \" + message + \" result: \" + result)\n  }else {\n    def content = result\n    log.info(\"req body is : $content\")\n  }\n  \n  Map updateData = Maps.newHashMap();\n  updateData.put(\"token__c\", webhookToken);\n  updateData.put(\"webhookUrl__c\", webhookUrl);\n  \n  // UpdateAttribute attribute = UpdateAttribute.builder().triggerWorkflow(true).build()\n  def (Boolean err, Map data, String errMessage)  = Fx.object.update(apiName, keyId, updateData,UpdateAttribute.builder().triggerWorkflow(true).build())\n  if (err) {\n      log.error(\"获取对象异常\" + errMessage)\n  }\n  else {\n      log.info(\"update data is : $data\")\n  }\n  \n  UIAction alertAction = AlertAction.builder()\n      .type(\"default\")\n      .text(\"The Webhook URL Generated Success.\")\n      .build()\n  return alertAction\n} else {\n  UIAction alertAction = AlertAction.builder()\n      .type(\"default\")\n      .text(\"The Webhook URL has been generated already.\")\n      .build()\n  return alertAction\n}\n// Return the AlertAction\n",
    "bindingObjectApiName": "WebhookURL__c",
    "type": "function",
    "nameSpace": "button",
    "returnType": "UIAction",
    "tenantId": "67000207",
    "lang": 0
  },
  "function:TestPushFunction": {
    "updateTime": 1767074664251,
    "name": "TestPushFunction",
    "apiName": "TestPushFunction__c",
    "content": "log.info('success!');",
    "bindingObjectApiName": "ESign_Record__c",
    "type": "function",
    "nameSpace": "button",
    "returnType": "UIAction",
    "tenantId": "67000207",
    "lang": 0
  },
  "function:TestNamespaceReturnFunction": {
    "updateTime": 1767074664252,
    "name": "TestNamespaceReturnFunction",
    "apiName": "TestNamespaceReturnFunction__c",
    "content": "log.info('success!');",
    "bindingObjectApiName": "ESign_Record__c",
    "type": "function",
    "nameSpace": "button",
    "returnType": "UIAction",
    "tenantId": "67000207",
    "lang": 0
  },
  "function:MyButtonAction": {
    "updateTime": 1767074664253,
    "name": "MyButtonAction",
    "apiName": "MyButtonAction__c",
    "content": "log.info('success!');",
    "bindingObjectApiName": "AccountObj",
    "type": "function",
    "nameSpace": "button",
    "returnType": "UIAction",
    "tenantId": "67000207",
    "lang": 0
  },
  "function:LunchSignService": {
    "updateTime": 1767074664255,
    "name": "LunchSignService",
    "apiName": "LunchSignService__c",
    "content": "/**\n * @author 彭黄振Jame\n * @codeName LunchSignService\n * @description Lunch Sign Service\n * @createTime 2025-10-11\n * @bindingObjectLabel Service Report ESignature\n * @bindingObjectApiName adobe_sign__c\n * @函数需求编号\n */\n    String key = ESignInfo.getKey();\n    log.info(key)\n    String baseUrl = ESignInfo.getBaseURL();\n    log.info(baseUrl)\n    \n    String keyId = context.data._id as String;\n    String innerMail = context.data.employee_email__c as String;\n    String innerName = context.data.employee_name__c as String;\n    \n    Map serviceReport = context.data.sign_file__c as Map\n    log.info(\"serviceReport:\" + serviceReport[0]['path']);\n    String nPath = context.data.npath__c as String;\n    \n    //  1. Transient Documents\n    String filePath = serviceReport[0]['path'] as String;\n    String uri = \"/api/rest/v6/transientDocuments\"\n    \n    String transientDocumentId = ESTransientDocService.uploadAndGetTransientId(baseUrl,key,filePath,nPath,uri)\n    \n    log.info(\"transientDocumentId:\" + transientDocumentId)\n    \n    // 更新adobe sign 的transientDocumentId\n    Map objectMap = [\"multi_line_text__c\": transientDocumentId]\n    Map resultBBB = Fx.object.update(\"adobe_sign__c\", keyId, objectMap, null, ActionAttribute.create()).result(); \n    log.info(\"=====resultBBB=====\" + resultBBB)\n\n    log.info(\"1. Transient Documents  send  end>>>>>>>>>>>>>>>>>>>\")\n      \n      \n     // 2. create agreement \n\n    // 协议头名称\n    String signName = \"MyTestAgreement\"\n    String agreementURI = \"/api/rest/v6/agreements\"\n    \n    //outter mail attach\n    \n    List outterSingers = context.data.signers_name__c as List \n    \n    // String contactEmailStrs = \"\";\n    List participantOuterSetsInfoList =[]\n    //遍历 outterSingers\n    if (outterSingers) {\n      \n      outterSingers.each {\n        item ->\n        log.info(item)\n        \n        //客户联系人\n        String contact_id = item\n        \n        //根据主键contact_id查询联系人对象ContactObj数据\n        \n        APIResult contactRet = Fx.object.findOne(\n          \"ContactObj\",\n          FQLAttribute.builder()\n            .columns([\"_id\", \"name\", \"email\"])\n            .queryTemplate(QueryTemplate.AND([\"_id\": QueryOperator.EQ(contact_id)]))\n            .build(),\n          SelectAttribute.builder()\n            .build()\n        );\n        if (contactRet.isError()) {\n          log.info(contactRet.message());\n        }\n        \n        //联系人邮箱\n        String email = contactRet.data[\"email\"] as String\n        String name = contactRet.data[\"name\"] as String\n            \n        List outterMembersList = []\n        \n        Map outterEmailMap = [:]\n        \n        outterEmailMap.put(\"email\",email)  \n        outterMembersList.add(outterEmailMap)\n        \n        Map participantOutterMap = [:]\n        \n        participantOutterMap.put(\"order\",1)\n        participantOutterMap.put(\"role\",\"SIGNER\")\n        participantOutterMap.put(\"name\",name)\n        participantOutterMap.put(\"memberInfos\",outterMembersList)\n        participantOuterSetsInfoList.add(participantOutterMap)\n        \n      }\n    }\n    \n    //提交合约并获取ID\n    String agreementId = ESAgreementService.createAgreement(signName,\n                                                            baseUrl,\n                                                            key,\n                                                            agreementURI,\n                                                            transientDocumentId,\n                                                            innerMail,\n                                                            innerName,\n                                                            participantOuterSetsInfoList\n                                                            ); \n    \n    log.info(\"agreementId:\" + agreementId)\n    \n     // 更新adobe sign 的agreementId\n    def objectMapCCC = [\"agreementId__c\": agreementId,\"signature_status__c\": \"In Progress\"]\n    def resultCCC = Fx.object.update(\"adobe_sign__c\", keyId, objectMapCCC, null, ActionAttribute.create()).result() as Map\n    log.info(\"resultCCC:\" + resultCCC)",
    "bindingObjectApiName": "adobe_sign__c",
    "type": "function",
    "nameSpace": "button",
    "returnType": "void",
    "tenantId": "67000207",
    "lang": 0
  },
  "function:GetESigningUrl": {
    "updateTime": 1767074664257,
    "name": "GetESigningUrl",
    "apiName": "GetESigningUrl__c",
    "content": "/**\n * @author 彭黄振Jame\n * @codeName GetESigningUrl\n * @description 获取电子签url链接\n * @createTime 2025-10-11\n * @bindingObjectLabel Service Report ESignature\n * @bindingObjectApiName adobe_sign__c\n * @函数需求编号\n */\nString apiName = context.data.object_describe_api_name as String;\n    \n    String esignUrl = \"\";\n    \n    String key = ESignInfo.getKey();\n    log.info(key)\n    String baseUrl = ESignInfo.getBaseURL();\n    log.info(baseUrl)\n    String uri = \"/api/rest/v6/agreements/\";\n    log.info(uri)\n    String agreementId = \"\";\n    \n    if (apiName == 'adobe_sign__c') {\n\n      agreementId = context.data.agreementId__c;\n      \n    } else if (apiName == \"reportability__c\") {\n      \n      agreementId = context.data.agreementId__c;\n      \n    }\n    \n    if (agreementId) {\n      \n      log.info(\"get  signingUrls >>>>>>>>>>>>>>>> \")\n      \n      esignUrl = ESAgreementService.getAgreementURL(baseUrl,key,uri,agreementId)\n      \n      log.info(\"esignUrl:\" + esignUrl)\n  \n    }\n\n    String source = Fx.utils.getRequestSource()\n    Fx.log.info(source)\n    UIAction action = null\n    if( source == \"WEB\" ) {\n      //web端返回 WebAction\n      action = WebAction.builder()\n        .type('url')//组件类型是 跳转 url\n        .url(esignUrl)//跳转的 url 地址\n        .build()\n    } else {\n      //移动端需要返回AppAction\n      action = AppAction.builder() \n        .url(esignUrl)\n        .build()\n    }\n    \n    return action",
    "bindingObjectApiName": "adobe_sign__c",
    "type": "function",
    "nameSpace": "button",
    "returnType": "UIAction",
    "tenantId": "67000207",
    "lang": 0
  },
  "function:FetchDocusignFile": {
    "updateTime": 1767074664258,
    "name": "ES Fetch Docusign File",
    "apiName": "FetchDocusignFile__c",
    "content": "/**\n * @author 彭黄振Jame\n * @codeName 测试请求\n * @description 测试请求\n * @createTime 2025-10-17\n * @bindingObjectLabel ESign记录表\n * @bindingObjectApiName ESign_Record__c\n * @函数需求编号\n */\n    String apiName = context.data.object_describe_api_name as String;\n    String keyId = context.data._id as String;\n\n    ESignInfo.configName = \"Docusign\"\n    String key = DocuSignAuth.getAccessToken() as String\n    log.info \"accessToken:$key\"\n    String baseUrl = ESignInfo.getBaseURL();\n    log.info(baseUrl)\n    String accountId = ESignInfo.getAccountId()\n    log.info \"AccountId:$accountId\"\n    //获取附件信息\n    String agreementId = context.data.agreementId__c as String;\n    String uri = \"/restapi/v2.1/accounts/\"+accountId\n    Map fileUrlMap = ESAgreementService.getAgreementDocuSignedFileURL(baseUrl,key,uri,agreementId)\n    // 将获取的附件构建并上传到文件服务器\n    Object xmap = fileUrlMap[1] as Object\n    String path = xmap[\"path\"] as String\n    String size = xmap[\"size\"] as String\n    String fileName = context.data.npath__c as String\n    String extensionName = \"pdf\"\n    \n\n    List fileInfo = [[\"path\":path,\"size\":size,\"ext\":extensionName,\"filename\": fileName+\".\"+extensionName]]\n    //更新上传附件\n    Map updateData = Maps.newHashMap();\n    updateData.put(\"finalfile__c\", fileInfo);\n    updateData.put(\"sign_status__c\", \"Completed\");\n\n    UpdateAttribute attribute = UpdateAttribute.builder().triggerWorkflow(true).build();\n    \n    def result = Fx.object.update(apiName, keyId, updateData,attribute).result() as Map\n    log.info(\"result:\" + result)\n    \n    UIAction alertAction = AlertAction.builder()\n      .type(\"default\")\n      .text(\"Signed Docs Fetched Success!\")\n      .build()\n    \n    // Return the AlertAction\n    return alertAction",
    "bindingObjectApiName": "ESign_Record__c",
    "type": "function",
    "nameSpace": "button",
    "returnType": "UIAction",
    "tenantId": "67000207",
    "lang": 0
  },
  "function:ESignURLService": {
    "updateTime": 1767074664260,
    "name": "ES AcrobatSign URL Service",
    "apiName": "ESignURLService__c",
    "content": "/**\n * @author 彭黄振Jame\n * @codeName GetESigningUrl\n * @description 获取电子签url链接\n * @createTime 2025-10-11\n * @bindingObjectLabel Service Report ESignature\n * @bindingObjectApiName adobe_sign__c\n * @函数需求编号\n */\nString apiName = context.data.object_describe_api_name as String;\n    \n    String esignUrl = \"\";\n    ESignInfo.configName = \"Adobe Sign\"\n    String key = ESignInfo.getKey();\n    log.info(key)\n    String baseUrl = ESignInfo.getBaseURL();\n    log.info(baseUrl)\n    String uri = \"/api/rest/v6/agreements/\";\n    log.info(uri)\n    String agreementId = \"\";\n    \n    if (apiName == 'ESign_Record__c') {\n\n      agreementId = context.data.agreementId__c;\n      \n    } else if (apiName == \"reportability__c\") {\n      \n      agreementId = context.data.agreementId__c;\n      \n    }\n    \n    if (agreementId) {\n      \n      log.info(\"get  signingUrls >>>>>>>>>>>>>>>> \")\n      \n      esignUrl = ESAgreementService.getAgreementURL(baseUrl,key,uri,agreementId)\n      \n      log.info(\"esignUrl:\" + esignUrl)\n  \n    }\n\n    String source = Fx.utils.getRequestSource()\n    Fx.log.info(source)\n    UIAction action = null\n    if( source == \"WEB\" ) {\n      //web端返回 WebAction\n      action = WebAction.builder()\n        .type('url')//组件类型是 跳转 url\n        .url(esignUrl)//跳转的 url 地址\n        .build()\n    } else {\n      //移动端需要返回AppAction\n      action = AppAction.builder() \n        .url(esignUrl)\n        .build()\n    }\n    \n    return action",
    "bindingObjectApiName": "ESign_Record__c",
    "type": "function",
    "nameSpace": "button",
    "returnType": "UIAction",
    "tenantId": "67000207",
    "lang": 0
  },
  "function:ESignService": {
    "updateTime": 1767074664261,
    "name": "ES AcrobatSign Service",
    "apiName": "ESignService__c",
    "content": "/**\n * @author 彭黄振Jame\n * @codeName LunchSignService\n * @description Lunch Sign Service\n * @createTime 2025-10-11\n * @bindingObjectLabel Service Report ESignature\n * @bindingObjectApiName adobe_sign__c\n * @函数需求编号\n */\n    ESignInfo.configName = 'Adobe Sign';\n    String key = ESignInfo.getKey();\n    log.info(key)\n    String baseUrl = ESignInfo.getBaseURL();\n    log.info(baseUrl)\n    List signers = context.data.signers__c as List \n    String keyId = context.data._id as String;\n    String innerMail = context.data.initiator_email__c as String;\n    String innerName = context.data.initiator_name__c as String;\n\n    Map serviceReport = context.data.sign_file__c as Map\n    log.info(\"serviceReport:\" + serviceReport[0]['path']);\n    String nPath = context.data.npath__c as String;\n    \n    //  1. Transient Documents\n    String filePath = serviceReport[0]['path'] as String;\n    String uri = \"/api/rest/v6/transientDocuments\"\n    \n    String transientDocumentId = ESTransientDocService.uploadAndGetTransientId(baseUrl,key,filePath,nPath,uri)\n    \n    log.info(\"transientDocumentId:\" + transientDocumentId)\n    \n    // 更新adobe sign 的transientDocumentId\n    Map objectMap = [\"transitDocId__c\": transientDocumentId]\n    Integer c = signers.size() as Integer\n    objectMap.put(\"signersCount__c\",c.toString())\n    Map resultBBB = Fx.object.update(\"ESign_Record__c\", keyId, objectMap, null, ActionAttribute.create()).result(); \n    log.info(\"=====resultBBB=====\" + resultBBB)\n\n    log.info(\"1. Transient Documents  send  end>>>>>>>>>>>>>>>>>>>\")\n      \n      \n     // 2. create agreement \n\n    // 协议头名称\n    String signName = nPath\n    String agreementURI = \"/api/rest/v6/agreements\"\n    \n    //outter mail attach\n    \n    List outterSingers = signers \n    \n    // String contactEmailStrs = \"\";\n    List participantOuterSetsInfoList =[]\n    //遍历 outterSingers\n    if (outterSingers) {\n      \n      outterSingers.each {\n        item ->\n        log.info(item)\n        \n        //客户联系人\n        String contact_id = item\n        \n        //根据主键contact_id查询联系人对象ContactObj数据\n        \n        APIResult contactRet = Fx.object.findOne(\n          \"ContactObj\",\n          FQLAttribute.builder()\n            .columns([\"_id\", \"name\", \"email\"])\n            .queryTemplate(QueryTemplate.AND([\"_id\": QueryOperator.EQ(contact_id)]))\n            .build(),\n          SelectAttribute.builder()\n            .build()\n        );\n        if (contactRet.isError()) {\n          log.info(contactRet.message());\n        }\n        \n        //联系人邮箱\n        String email = contactRet.data[\"email\"] as String\n        String name = contactRet.data[\"name\"] as String\n            \n        List outterMembersList = []\n        \n        Map outterEmailMap = [:]\n        \n        outterEmailMap.put(\"email\",email)  \n        outterMembersList.add(outterEmailMap)\n        \n        Map participantOutterMap = [:]\n        \n        participantOutterMap.put(\"order\",1)\n        participantOutterMap.put(\"role\",\"SIGNER\")\n        participantOutterMap.put(\"name\",name)\n        participantOutterMap.put(\"memberInfos\",outterMembersList)\n        participantOuterSetsInfoList.add(participantOutterMap)\n        \n      }\n    }\n    \n    //提交合约并获取ID\n    String agreementId = ESAgreementService.createAgreement(signName,\n                                                            baseUrl,\n                                                            key,\n                                                            agreementURI,\n                                                            transientDocumentId,\n                                                            innerMail,\n                                                            innerName,\n                                                            participantOuterSetsInfoList\n                                                            ); \n    \n    log.info(\"agreementId:\" + agreementId)\n    \n     // 更新adobe sign 的agreementId\n    def objectMapCCC = [\"agreementId__c\": agreementId,\"sign_status__c\": \"In Progress\"]\n    def resultCCC = Fx.object.update(\"ESign_Record__c\", keyId, objectMapCCC, null, ActionAttribute.create()).result() as Map\n    log.info(\"resultCCC:\" + resultCCC)",
    "bindingObjectApiName": "ESign_Record__c",
    "type": "function",
    "nameSpace": "button",
    "returnType": "void",
    "tenantId": "67000207",
    "lang": 0
  },
  "function:ESignFetchSignedDoc": {
    "updateTime": 1767074664264,
    "name": "ESignFetchSignedDoc",
    "apiName": "ESignFetchSignedDoc__c",
    "content": "/**\n * @author 彭黄振Jame\n * @codeName 测试请求\n * @description 测试请求\n * @createTime 2025-10-17\n * @bindingObjectLabel ESign记录表\n * @bindingObjectApiName ESign_Record__c\n * @nameSpace button\n * @returnType UIAction\n * @函数需求编号\n */\n    String apiName = context.data.object_describe_api_name as String;\n    String keyId = context.data._id as String;\n\n    ESignInfo.configName = 'Adobe Sign';\n    String key = ESignInfo.getKey();\n    log.info(key)\n    String baseUrl = ESignInfo.getBaseURL();\n    log.info(baseUrl)\n    \n    String agreementId = context.data.agreementId__c as String;\n    String uri = \"/api/rest/v6\";\n    Map fileUrlMap = ESAgreementService.getAgreementAcrobatSignedFileURL(baseUrl,key,uri,agreementId)\n    // 将获取的附件构建并上传到文件服务器\n    Object xmap = fileUrlMap[1] as Object\n    String path = xmap[\"path\"] as String\n    String size = xmap[\"size\"] as String\n    String fileName = context.data.npath__c as String\n    String extensionName = \"pdf\"\n    List fileInfo = [[\"path\":path,\"size\":size,\"ext\":extensionName,\"filename\": fileName+\".\"+extensionName]]\n    \n    Map updateData = Maps.newHashMap();\n    updateData.put(\"finalfile__c\", fileInfo);\n\n    UpdateAttribute attribute = UpdateAttribute.builder().triggerWorkflow(true).build();\n    \n    def result = Fx.object.update(apiName, keyId, updateData,attribute).result() as Map\n    log.info(\"result:\" + result)\n    \n    UIAction alertAction = AlertAction.builder()\n      .type(\"default\")\n      .text(\"Signed Docs Fetched Success!\")\n      .build()\n    \n    // Return the AlertAction\n    return alertAction",
    "bindingObjectApiName": "ESign_Record__c",
    "type": "function",
    "nameSpace": "button",
    "returnType": "UIAction",
    "tenantId": "67000207",
    "lang": 0
  },
  "function:DocuSignUrlService": {
    "updateTime": 1767074664265,
    "name": "ES DocuSign URL Service",
    "apiName": "DocuSignUrlService__c",
    "content": "/**\n * @author 彭黄振Jame\n * @codeName GetESigningUrl\n * @description 获取电子签url链接\n * @createTime 2025-10-11\n * @bindingObjectLabel Service Report ESignature\n * @bindingObjectApiName adobe_sign__c\n * @函数需求编号\n */\nString apiName = context.data.object_describe_api_name as String;\n    \n    String esignUrl = \"\";\n    \n    ESignInfo.configName = \"Docusign\"\n    String key = DocuSignAuth.getAccessToken() as String\n    log.info \"accessToken:$key\"\n    String baseUrl = ESignInfo.getBaseURL()\n    log.info \"baseUrl:$baseUrl\"\n    String accountId = ESignInfo.getAccountId()\n    log.info \"AccountId:$accountId\"\n    //获取附件信息\n    String inemail = context.data.initiator_email__c as String;\n    String inname = context.data.initiator_name__c as String;\n    String agreementId = context.data.agreementId__c as String;\n    String uri = \"/restapi/v2.1/accounts/\"+accountId+\"/envelopes/\"+agreementId+\"/views/recipient\";\n    log.info(uri)\n    \n    \n    if (agreementId) {\n      \n      log.info(\"get  signingUrls >>>>>>>>>>>>>>>> \")\n      Map bodyMap = [:]\n      bodyMap.put(\"authenticationMethod\",\"none\")\n      bodyMap.put(\"email\",inemail)\n      bodyMap.put(\"userName\",inname)\n      bodyMap.put(\"clientUserId\",\"1\")\n      bodyMap.put(\"returnUrl\",\"https://www.fxiaoke.com\")\n      \n      esignUrl = ESAgreementService.getDocusignAgreementURL(baseUrl,key,uri,bodyMap)\n      \n  \n    }\n\n    String source = Fx.utils.getRequestSource()\n    Fx.log.info(source)\n    UIAction action = null\n    if( source == \"WEB\" ) {\n      //web端返回 WebAction\n      action = WebAction.builder()\n        .type('url')//组件类型是 跳转 url\n        .url(esignUrl)//跳转的 url 地址\n        .build()\n    } else {\n      //移动端需要返回AppAction\n      action = AppAction.builder() \n        .url(esignUrl)\n        .build()\n    }\n    \n    return action",
    "bindingObjectApiName": "ESign_Record__c",
    "type": "function",
    "nameSpace": "button",
    "returnType": "UIAction",
    "tenantId": "67000207",
    "lang": 0
  },
  "function:DocuSignService": {
    "updateTime": 1767074664267,
    "name": "ES DocuSign Service",
    "apiName": "DocuSignService__c",
    "content": "/**\n * @author 彭黄振Jame\n * @codeName LunchSignService\n * @description Lunch Sign Service\n * @createTime 2025-10-11\n * @bindingObjectLabel Service Report ESignature\n * @bindingObjectApiName adobe_sign__c\n * @函数需求编号\n */\n\n    \n    ESignInfo.configName = \"Docusign\"\n    String key = DocuSignAuth.getAccessToken() as String\n    log.info \"accessToken:$key\"\n    String baseUrl = ESignInfo.getBaseURL()\n    log.info \"baseUrl:$baseUrl\"\n    String accountId = ESignInfo.getAccountId()\n    log.info \"AccountId:$accountId\"\n    \n    List signers = context.data.signers__c as List \n    String keyId = context.data._id as String;\n    String innerMail = context.data.initiator_email__c as String;\n    String innerName = context.data.initiator_name__c as String;\n\n    Map serviceReport = context.data.sign_file__c as Map\n    log.info(\"serviceReport:\" + serviceReport[0]['path']);\n    String nPath = context.data.npath__c as String;\n    \n    String agreementId = \"\"\n    \n    //  1. Transient Documents\n    String filePath = serviceReport[0]['path'] as String;\n    String uri = \"/restapi/v2.1/accounts/\"+accountId+\"/envelopes\"\n    List participants = signers \n    Integer num = 1\n    def signer = [\n                      email       : innerMail,\n                      name        : innerName,\n                      recipientId : num as String,\n                      routingOrder: num as String,\n                      tabs        : [\n                          signHereTabs: [          // 注意：这里是 List\n                              [\n                                  anchorString : '/sig1/',\n                                  anchorYOffset: '10',\n                                  anchorXOffset: '20'\n                              ]\n                          ]\n                      ]\n                  ]\n    List recipientList = [signer]\n    \n    if( participants ){\n      \n        participants.each{\n            item->\n            //客户联系人\n            String contact_id = item\n            num++\n            //根据主键contact_id查询联系人对象ContactObj数据\n            \n            APIResult contactRet = Fx.object.findOne(\n              \"ContactObj\",\n              FQLAttribute.builder()\n                .columns([\"_id\", \"name\", \"email\"])\n                .queryTemplate(QueryTemplate.AND([\"_id\": QueryOperator.EQ(contact_id)]))\n                .build(),\n              SelectAttribute.builder()\n                .build()\n            );\n            if (contactRet.isError()) {\n              log.info(contactRet.message());\n            }\n            \n            //联系人邮箱\n            String email1 = contactRet.data[\"email\"] as String\n            String name1 = contactRet.data[\"name\"] as String\n            // String contId = contactRet.data[\"_id\"] as String\n            recipientList.add([\n                          email       : email1,\n                          name        : name1,\n                          recipientId : num as String,\n                          routingOrder: num as String,\n                          tabs        : [\n                              signHereTabs: [          // 注意：这里是 List\n                                  [\n                                      anchorString : '/sig1/',\n                                      anchorYOffset: '10',\n                                      anchorXOffset: '20'\n                                  ]\n                              ]\n                          ]\n              ])\n          \n        }\n    }\n    \n    def envelopeJson = [\n        emailSubject: '请签署'+nPath,\n        documents: [[\n            documentId: '1',\n            name: nPath\n        ]],\n        recipients: [\n            signers: recipientList\n        ],\n        status: 'sent'\n    ] as Map\n    log.info \"envelopeJson:$envelopeJson\"\n    \n    agreementId = ESTransientDocService.uploadAndGetDocusignTransientId(baseUrl,key,filePath,nPath,uri,envelopeJson)\n    \n    log.info(\"agreementId:\" + agreementId)\n    \n    // 更新adobe sign 的agreementId\n    def objectMapCCC = [\"agreementId__c\": agreementId,\"sign_status__c\": \"In Progress\",\"signersCount__c\":num]\n    def resultCCC = Fx.object.update(\"ESign_Record__c\", keyId, objectMapCCC, null, ActionAttribute.create()).result() as Map\n    log.info(\"resultCCC:\" + resultCCC)\n    \n    ",
    "bindingObjectApiName": "ESign_Record__c",
    "type": "function",
    "nameSpace": "button",
    "returnType": "void",
    "tenantId": "67000207",
    "lang": 0
  },
  "class:WebHookController": {
    "updateTime": 1767074664920,
    "name": "WebHookController",
    "apiName": "WebHookController__c",
    "content": "/**\n * @author 彭黄振Jame\n * @codeName WebHookController\n * @description WebHookController\n * @createTime 2025-10-13\n * @bindingObjectLabel --\n * @bindingObjectApiName NONE\n * @函数需求编号\n */\n\n\n/**\n * @type classes\n * @returntype\n * @namespace apl_controller\n */\n@AplController(baseUrl = \"/apl\")\nclass WebHookController {\n\n    @AplRequestMapping(value = \"/query\", method = RequestMethod.POST)\n    public HttpResponse query(HttpRequest request) {\n        String requestBody = new String(request.getBody(), \"UTF-8\")\n        log.info(requestBody)\n\n        Map returnBody = [\"code\": 0, \"data\": \"ook\", \"message\": \"success!\"]\n        String body = Fx.json.toJson(returnBody)\n        return HttpResponse.ok()\n                .header(\"Content-Type\", \"application/json\")\n                .body(body)\n    }\n    \n    // @AplRequestMapping(value = \"/getmethod\", method = RequestMethod.GET)\n    // public HttpResponse getMethod(HttpRequest request) {\n    //     String requestBody = new String(request.getBody(), \"UTF-8\")\n    //     log.info(requestBody)\n    //\n    //     Map returnBody = [\"xAdobeSignClientId\":\"ats-1e6bdecd-7ca6-4e5f-9ef6-05068f29712d\"]\n    //     String body = Fx.json.toJson(returnBody)\n    //     return HttpResponse.ok()\n    //             .header(\"Content-Type\", \"application/json\")\n    //             .body(body)\n    // }\n\n    /**\n     * 硬编码方法：获取AplRequestMapping路径映射\n     * @return Map<String, String> 方法名到路径的映射\n     */\n    public Map<String, String> getAplRequestMappingPaths() {\n        Map<String, String> pathMapping = [:]\n        \n        // 硬编码添加所有AplRequestMapping的路径\n        pathMapping.put(\"query\", \"/apl/query\")\n        pathMapping.put(\"getMethod\", \"/apl/getmethod\")\n        \n        return pathMapping\n    }\n\n    public void debug(FunctionContext context, Map<String, Object> args) {\n        Map headers = [\n                \"Content-Type\": [\"application/json\"]\n        ]\n        Map parameters = [\n                \"name\": [\"zhangsan\"]\n        ]\n        byte[] body = [1, 2, 3] as byte[]\n        HttpRequest request = new HttpRequest(headers, parameters, body)\n        log.info(Fx.json.toJson(query(request)))\n        \n        // 测试获取路径映射\n        log.info(\"AplRequestMapping Paths: \" + Fx.json.toJson(getAplRequestMappingPaths()))\n        \n        // request = new HttpRequest(headers, parameters, body)\n        // log.info(\"====result: \" + Fx.json.toJson(getMethod(request)))\n    }\n}",
    "bindingObjectApiName": "NONE",
    "type": "class",
    "nameSpace": "apl_controller",
    "returnType": "",
    "tenantId": "67000207",
    "lang": 0
  },
  "class:Triggers": {
    "updateTime": 1767074664924,
    "name": "Triggers",
    "apiName": "Triggers__c",
    "content": "/**\n * @author 彭黄振Jame\n * @codeName Triggers\n * @description Triggers handlers使用\n * @createTime 2025-10-11\n * @bindingObjectLabel --\n * @bindingObjectApiName NONE\n * @函数需求编号\n */\n\n\n/**\n * @type classes\n * @returntype\n * @namespace library\n */\nclass Triggers {\n  \n    interface Handler { void handle() }\n\n    private List<Triggers.Handler> handlers = []\n\n    Triggers bind(Triggers.Handler h) {\n        if (h) handlers << h\n        return this\n    }\n\n    Triggers bind(Closure c) {\n        if (c) handlers << ({ -> c() } as Triggers.Handler)   // 包一层\n        return this\n    }\n\n    void manage() { handlers.each { it.handle() } }\n\n    //对外提供的方法\n    static String action() {\n        return \"sucesss\"\n    }\n\n    //debug 时候的入口方法\n    static void main(String[] args) {\n        String ret = action();\n        log.info(ret)\n    }\n\n}\n",
    "bindingObjectApiName": "NONE",
    "type": "class",
    "nameSpace": "library",
    "returnType": "",
    "tenantId": "67000207",
    "lang": 0
  },
  "class:ShortSnowflakeIdUtil": {
    "updateTime": 1767074664927,
    "name": "ShortSnowflakeIdUtil",
    "apiName": "ShortSnowflakeIdUtil__c",
    "content": "/**\n * @author 彭黄振Jame\n * @codeName ShortSnowflakeIdUtil\n * @description 20位以内短雪花ID（无位运算、无循环，APL兼容）\n * @createTime 2025-10-19\n * @bindingObjectLabel --\n * @bindingObjectApiName NONE\n * @函数需求编号\n */\n\n/**\n * @type classes\n * @returntype String\n * @namespace library\n */\nclass ShortSnowflakeIdUtil {\n\n    /*========== 可外部注入的参数 ==========*/\n    private static Long workerId     = 1L   // 0~31\n    private static Long datacenterId = 1L   // 0~31\n\n    /*========== 常量 ==========*/\n    private static Long TWPOCH = 1420041600000L   // 2015-01-01 00:00:00\n    private static Long SEQUENCE_BITS  = 12L\n    private static Long WORKER_BITS    = 5L\n    private static Long DATACENTER_BITS= 5L\n\n    private static Long MAX_SEQUENCE   = 4095L      // 2^12-1\n    private static Long MAX_WORKER     = 31L        // 2^5-1\n    private static Long MAX_DATACENTER = 31L        // 2^5-1\n\n    /*========== 运行时变量 ==========*/\n    private static Long sequence  = 0L\n    private static Long lastTime  = -1L\n\n    /*========== 对外 API ==========*/\n    /** 生成下一个全局唯一ID（字符串） */\n    public static String nextId() {\n        return generateId()\n    }\n\n    /*========== 私有实现 ==========*/\n    private static synchronized String generateId() {\n        Long now = System.currentTimeMillis()\n        if (now < lastTime) {\n            log.info(\"Clock moved backwards\")\n        }\n\n        if (now == lastTime) {\n            sequence = sequence + 1\n            if (sequence > MAX_SEQUENCE) {\n                // 序列耗尽，直接等到下一毫秒（APL不支持while，用递归代替）\n                return waitNextMillis(lastTime)\n            }\n        } else {\n            sequence = 0\n        }\n\n        lastTime = now\n\n        /* 代替位运算的乘加拼装 */\n        Long timePart  = (now - TWPOCH) * 4194304L          // 左移22位：2^(5+5+12)\n        Long dataPart  = datacenterId * 131072L             // 左移17位：2^(5+12)\n        Long workPart  = workerId     * 4096L               // 左移12位\n        Long id = timePart + dataPart + workPart + sequence\n\n        return id.toString()\n    }\n\n    /** 递归等待下一毫秒（替代while） */\n    private static String waitNextMillis(Long last) {\n        Long t = System.currentTimeMillis()\n        if (t <= last) {\n            // 仍没越过上一毫秒，继续递归\n            return waitNextMillis(last)\n        }\n        // 时间已更新，重新生成ID\n        return generateId()\n    }\n\n    /*========== 调试入口 ==========*/\n    static void main(String[] args) {\n        log.info(\"ShortSnowflakeIdUtil test => \" + nextId())\n        def str = '{\"baseurl\":\"https://www.fxiaoke.com\",\"method\":{\"POST\":\"/postmethod\",\"GET\":\"/getmethod\"},\"cert\":\"ZXlKaGJHY2lPaUpJVXpJMU5pSXNJblI1Y0NJNklrcFhWQ0o5LmV5SnpkV0lpT2lKU1pYRjFaWE4wVkc5clpXNGlMQ0pwYzNNaU9pSkRSVkF0VTJWeWRtVnlJaXdpWlc1MFpYSndjbWx6WlVGalkyOTFiblFpT2lKbWEzUmxjM1E0TlRBM0lpd2laVzUwWlhKd2NtbHpaVWxrSWpvNE1qUXpNRElzSW5ObGMzTnBiMjVKWkNJNklqWTRZMk14TTJZNExUZ3lNVEV0TkRnd01TMDRNVEkwTFdKaFlqSm1NR0prTTJJNE55SXNJbVY0Y0NJNk16Z3pOVFE0TWpJME15d2lkWE5sY2tsa0lqb3hNREF3TENKcFlYUWlPakUzTmpBd05qQTRNakY5LjNQcC14MTB2TmJFYUpzZ3ZBQTJzZmc5Zk5RV09sWjhUTGFtY2cyaEpuYjA=\"}'\n        def encode1 = Fx.crypto.MD5.encode(str)\n        log.info(\"MD5 test => \" +encode1)\n    }\n}",
    "bindingObjectApiName": "NONE",
    "type": "class",
    "nameSpace": "library",
    "returnType": "",
    "tenantId": "67000207",
    "lang": 0
  },
  "class:NewTestClass2": {
    "updateTime": 1767074664930,
    "name": "NewTestClass2",
    "apiName": "NewTestClass2__c",
    "content": "//demo\nclass NewTestClass2 {\n  \n  //对外提供的方法\n  public static String action(){\n    return \"success\"\n  }\n  \n  //debug 时候的入口方法\n  public static void main(String[] args){\n    String ret = action();\n    log.info(ret)\n  }\n  \n}\n",
    "bindingObjectApiName": "NONE",
    "type": "class",
    "nameSpace": "library",
    "returnType": "",
    "tenantId": "67000207",
    "lang": 0
  },
  "class:NewTestClass": {
    "updateTime": 1767074664932,
    "name": "NewTestClass",
    "apiName": "NewTestClass__c",
    "content": "//demo\nclass NewTestClass {\n  \n  //对外提供的方法\n  public static String action(){\n    return \"success\"\n  }\n  \n  //debug 时候的入口方法\n  public static void main(String[] args){\n    String ret = action();\n    log.info(ret)\n  }\n  \n}\n",
    "bindingObjectApiName": "NONE",
    "type": "class",
    "nameSpace": "library",
    "returnType": "",
    "tenantId": "67000207",
    "lang": 0
  },
  "class:NewTestAgainClass": {
    "updateTime": 1767074664934,
    "name": "NewTestAgainClass",
    "apiName": "NewTestAgainClass__c",
    "content": "//demo\nclass NewTestAgainClass {\n  \n  //对外提供的方法\n  public static String action(){\n    return \"success\"\n  }\n  \n  //debug 时候的入口方法\n  public static void main(String[] args){\n    String ret = action();\n    log.info(ret)\n  }\n  \n}\n",
    "bindingObjectApiName": "NONE",
    "type": "class",
    "nameSpace": "library",
    "returnType": "",
    "tenantId": "67000207",
    "lang": 0
  },
  "class:MyTestClass": {
    "updateTime": 1767074664935,
    "name": "MyTestClass",
    "apiName": "MyTestClass__c",
    "content": "//demo\nclass MyTestClass {\n  \n  //对外提供的方法\n  public static String action(){\n    return \"success\"\n  }\n  \n  //debug 时候的入口方法\n  public static void main(String[] args){\n    String ret = action();\n    log.info(ret)\n  }\n  \n}\n",
    "bindingObjectApiName": "NONE",
    "type": "class",
    "nameSpace": "library",
    "returnType": "",
    "tenantId": "67000207",
    "lang": 0
  },
  "class:MyLibraryClass": {
    "updateTime": 1767074664938,
    "name": "MyLibraryClass",
    "apiName": "MyLibraryClass__c",
    "content": "//demo\nclass MyLibraryClass {\n  \n  //对外提供的方法\n  public static String action(){\n    return \"success\"\n  }\n  \n  //debug 时候的入口方法\n  public static void main(String[] args){\n    String ret = action();\n    log.info(ret)\n  }\n  \n}\n",
    "bindingObjectApiName": "NONE",
    "type": "class",
    "nameSpace": "library",
    "returnType": "",
    "tenantId": "67000207",
    "lang": 0
  },
  "class:MyHandler": {
    "updateTime": 1767074664941,
    "name": "MyHandler",
    "apiName": "MyHandler__c",
    "content": "/**\n * @author 彭黄振Jame\n * @codeName MyHandler\n * @description MyHandler\n * @createTime 2025-10-11\n * @bindingObjectLabel --\n * @bindingObjectApiName NONE\n * @函数需求编号\n */\n\n\n/**\n * @type classes\n * @returntype\n * @namespace library\n */\nclass MyHandler implements Triggers.Handler {\n  \n    private String tag\n    MyHandler(String tag) { this.tag = tag }\n    void handle() { \n      log.info(\"my handler: \" + tag)\n      println \"my handler [$tag]\" \n      \n    }\n\n    //对外提供的方法\n    static String action() {\n        return \"sucesss\"\n    }\n\n    //debug 时候的入口方法\n    static void main(String[] args) {\n        def t = new Triggers()\n        t.bind(new MyHandler('A'))\n         .bind(new MyHandler('B'))\n         .manage()\n    }\n\n}\n",
    "bindingObjectApiName": "NONE",
    "type": "class",
    "nameSpace": "library",
    "returnType": "",
    "tenantId": "67000207",
    "lang": 0
  },
  "class:LoopUtilsTestClass": {
    "updateTime": 1767074664943,
    "name": "LoopUtilsTestClass",
    "apiName": "LoopUtilsTestClass__c",
    "content": "/**\n * @author 彭黄振Jame\n * @codeName AAATest\n * @description AAATest\n * @createTime 2025-10-25\n * @bindingObjectLabel --\n * @bindingObjectApiName NONE\n * @函数需求编号\n */\nimport fx.custom.apl.jar.LoopUtils\n\n/**\n * @type classes\n * @returntype\n * @namespace library\n */\nclass LoopUtilsTestClass {\n\n    //对外提供的方法\n    static String action() {\n        return \"sucesss\"\n    }\n\n    //debug 时候的入口方法\n    static void main(String[] args) {\n        log.info \"=== Groovy调用LoopUtils示例 ===\"\n        \n        // 1. 标准for循环示例\n        log.info \"[1. 标准for循环示例 (0到9)]：\"\n        LoopUtils.forLoop(0, 10, 1) { i ->\n            log.info \"$i \"\n        }\n        \n        // 示例1: for循环中使用breakLoop()方法 - 无需return或throw\n        log.info \"[1. for循环中使用breakLoop()]:\"\n        LoopUtils.forLoop(0, 10, 1, { int i ->\n            log.info \"  循环: $i\"\n            if (i == 5) {\n                log.info \"[执行breakLoop]\"\n                LoopUtils.breakLoop()  // 直接调用方法，无需return或throw\n            }\n        })\n        \n        // 示例2: for循环中使用continueLoop()方法 - 无需return或throw\n        log.info \"[2. for循环中使用continueLoop()]:\"\n        LoopUtils.forLoop(0, 10, 1, { int i ->\n            if (i % 2 == 0) {\n                log.info \"跳过偶数: $i\"\n                LoopUtils.continueLoop()  // 直接调用方法，无需return或throw\n            }\n            log.info \" 处理奇数: $i\"\n        })\n        \n        // 2. 带步长的for循环示例\n        log.info \"[2. 带步长的for循环示例 (0到20，步长为2)]：\"\n        LoopUtils.forLoop(0, 20, 2) { i ->\n            log.info \"$i \"\n        }\n        \n        // 示例: while循环中使用breakLoop()和continueLoop()\n        log.info \"[while循环中使用breakLoop()和continueLoop()]:\"\n        def count = 0\n        LoopUtils.whileLoop({ count < 10 }, {\n            count++\n            log.info \"While循环: $count\"\n            \n            if (count % 3 == 0) {\n                log.info \"跳过能被3整除的数: $count\"\n                LoopUtils.continueLoop()\n            }\n            \n            if (count == 7) {\n                log.info \"执行breakLoop\"\n                LoopUtils.breakLoop()\n            }\n        })\n        \n        \n    }\n\n}\n",
    "bindingObjectApiName": "NONE",
    "type": "class",
    "nameSpace": "library",
    "returnType": "",
    "tenantId": "67000207",
    "lang": 0
  },
  "class:HttpsService": {
    "updateTime": 1767074664945,
    "name": "HttpsService",
    "apiName": "HttpsService__c",
    "content": "/**\n * @author 彭黄振Jame\n * @codeName HttpsService\n * @description 公共callout service\n * @createTime 2025-10-11\n * @bindingObjectLabel --\n * @bindingObjectApiName NONE\n * @函数需求编号\n */\n\n\n/**\n * @type classes\n * @returntype\n * @namespace library\n */\nclass HttpsService {\n  \n    /**\n     * 统一 POST 发送 JSON（Adobe 协议创建场景）\n     * @param url        完整地址\n     * @param bearerKey  Bearer token\n     * @param bodyMap    请求体 Map（会被 StringBody 包装）\n     * @return [error, HttpResult, message] 三元组\n     */\n    static def postJson(String url, String bearerKey, Map bodyMap) {\n        StringBody body = StringBody.builder().content(bodyMap).build()\n        Request req = Request.builder()\n                             .method(\"POST\")\n                             .url(url)\n                             .timeout(75_000)\n                             .retryCount(0)\n                             .header(\"Content-Type\", \"application/json; charset=UTF-8\")\n                             .header(\"Authorization\", \"Bearer \" + bearerKey)\n                             .body(body)\n                             .build()\n        return http.execute(req)   // 返回三元组\n    }\n    \n    static def getWithBearer(String fullUrl, String bearerKey) {\n        Map headers = [\n            \"Accept\"        : \"application/json\",\n            \"Authorization\" : \"Bearer \" + bearerKey\n        ]\n        def (Boolean error, HttpResult result, String errorMsg) =\n                Fx.http.get(fullUrl, headers, 10_000, false, 0)\n        return [error, result, errorMsg]\n    }\n    \n    static def getFileWithBearer(String fullUrl, String bearerKey) {\n        Map headers = [\n            \"Content-Type\"        : \"application/pdf\",\n            \"Authorization\" : \"Bearer \" + bearerKey\n        ]\n        def (Boolean error, HttpResult result, String errorMsg) =\n                Fx.http.get(fullUrl, headers, 10_000, false, 0)\n        return [error, result, errorMsg]\n    }\n    \n    /**\n     * 统一上传 multipart/form-data（Adobe transientDocuments 场景）\n     * @param url        完整地址\n     * @param bearerKey  Bearer token\n     * @param fileName   文件名（不带后缀）\n     * @param inputStream 文件流\n     * @return [error, HttpResult, message] 三元组\n     */\n    static def postMultipart(String url,\n                             String bearerKey,\n                             String fileName,\n                             InputStream inputStream) {\n    \n        def multi = MultipartBody.builder()\n                                 .addPart(\"FileName\", fileName)\n        multi.addPart(\"File\", inputStream, fileName + '.pdf', 'application/pdf')\n        def finalMulti = multi.build()\n    \n        Request req = Request.builder()\n                             .method(\"POST\")\n                             .url(url)\n                             .timeout(70_000)\n                             .retryCount(0)\n                             .header(\"Content-Type\", \"multipart/form-data\")\n                             .header(\"accept\", \"application/json\")\n                             .header(\"Authorization\", \"Bearer \" + bearerKey)\n                             .body(finalMulti)\n                             .build()\n    \n        return http.execute(req)   // 依旧是三元组\n    }\n    \n    /**\n     * 统一上传 multipart/form-data; boundary=boundary123（Docusign transientDocuments 场景）\n     * @param url        完整地址\n     * @param bearerKey  Bearer token\n     * @param fileName   文件名（不带后缀）\n     * @param inputStream 文件流\n     * @return [error, HttpResult, message] 三元组\n     */\n    static def postDocsignMultipart(String url,\n                             String bearerKey,\n                             String fileName,\n                             InputStream inputStream,Map envelopeJson) {\n                               \n        def envStr = json.toJson(envelopeJson)\n        \n        def jsonPart = Strings.toUTF8Bytes(envStr)\n                               \n        def multi = MultipartBody.builder()\n        // JSON 部分\n        .addPart(\"form-data; name=\\\"envelopeDefinition\\\"\", jsonPart, \"request.json\", \"application/json\")\n        // PDF 文件部分\n        .addPart(\"file; filename=\\\"${fileName}\\\"; documentid=1\", inputStream, \"${fileName}\", \"application/pdf\")\n\n        def finalMulti = multi.build()\n    \n        // 3️⃣ 构建 HTTP 请求\n        def req = Request.builder()\n            .method(\"POST\")\n            .url(url)\n            .timeout(80_000)\n            .retryCount(0)\n            .header(\"Content-Type\", \"multipart/form-data; boundary=boundary123\")\n            .header(\"Accept\", \"application/json\")\n            .header(\"Authorization\", \"Bearer ${bearerKey}\")\n            .body(finalMulti)\n            .build()\n    \n        return http.execute(req)   // 依旧是三元组\n    }\n\n    //对外提供的方法\n    static String action() {\n        return \"sucesss\"\n    }\n\n    //debug 时候的入口方法\n    static void main(String[] args) {\n        String ret = action();\n        log.info(ret)\n    }\n\n}\n",
    "bindingObjectApiName": "NONE",
    "type": "class",
    "nameSpace": "library",
    "returnType": "",
    "tenantId": "67000207",
    "lang": 0
  },
  "class:ESignReceivedService": {
    "updateTime": 1767074664947,
    "name": "ESignReceivedService",
    "apiName": "ESignReceivedService__c",
    "content": "/**\n * @author 彭黄振Jame\n * @codeName ESign Received Service\n * @description ESign Received Service\n * @createTime 2025-10-17\n * @bindingObjectLabel --\n * @bindingObjectApiName NONE\n * @函数需求编号\n */\n\n\n/**\n * @type classes\n * @returntype\n * @namespace library\n */\nclass ESignReceivedService {\n    static Map getESignReceived(String repsBody){\n        def body = Fx.json.parse(repsBody) \n        log.info(\"I am here\")\n        def eventResourceType = body.eventResourceType //用于判断是否来自于“agreement”的事件请求\n        def event = body.event //用于判断是否完成\n        def participantRole = body.participantRole as String//签署人角色\n        def actingUserEmail = body.actingUserEmail as String//签署人邮箱\n        def agreement = body.agreement as Map \n        \n        String agreementId = agreement.id //用于找到主表记录进行更新\n        String agreeStatus = agreement.status as String \n        String apiName = \"ESign_Record__c\"\n        \n        if(eventResourceType == \"agreement\" &&\n           participantRole == \"SIGNER\" &&\n           event ==\"AGREEMENT_ACTION_COMPLETED\") {//全部签署完成\n           Map updateData = Maps.newHashMap();\n           \n           if(agreeStatus == \"SIGNED\"){\n             updateData.put(\"sign_status__c\", \"COMPLETED\");\n           }\n            \n           def (Boolean error, QueryResult data, String errorMessage) = Fx.object.find(apiName, //对象apiName\n                                                                            FQLAttribute.builder()\n                                                                                    .columns([\"_id\", \"name\"]) //需要返回的字段\n                                                                                    .queryTemplate(QueryTemplate.AND([\"agreementId__c\": QueryOperator.EQ(agreementId)])) //查询条件\n                                                                                    .build(),\n                                                                           SelectAttribute.builder()\n                                                                                    .needCalculate(true) //是否实时处理计算字段，默认true\n                                                                                    .needQuote(true) //是否实时处理引用字段，默认true\n                                                                                    .calculateCount(true) //是否实时处理统计字段，默认true\n                                                                                    .fillExtendInfo(false) //是否补充字段扩展信息，比如查找关联字段的主属性、人员部门名称等，以${字段apiName}__r返回，默认false\n                                                                                    .needOptionLabel(false) //是否返回单选、多选字段的label，以${字段apiName}__r返回，默认false\n                                                                                    .convertQuoteForView(false) //引用字段是否返回label，如果为true，引用字段的value通过${字段apiName}__v返回，默认false\n                                                                                    .needInvalid(false) //是否返回已作废的数据，默认false\n                                                                                    .needRelevantTeam(false) //是否返回相关团队，默认false\n                                                                                    .build())\n            if (error) {\n                log.error(\"获取对象异常\" + errorMessage)\n            \n            } else {\n                log.info(\"I am here1\")\n                def dataList = data.dataList as List\n                String keyId = \"\"\n                dataList.each {\n                    e ->\n                        //dosomething，将示例逻辑细化至业务数据层\n                        def map = e as Map\n                        keyId = map['_id'] as String\n                }\n                def (Boolean err, Map reslt, String errMessage) =  Fx.object.update(apiName, keyId, updateData, UpdateAttribute.builder().triggerWorkflow(true).build())\n                log.info(\"I am here2\")\n                if (err) {\n                    log.error(\"获取对象异常\" + errMessage)\n                }\n                else {\n                    log.info(\"update data is : $reslt\")\n                    collectSigners(actingUserEmail, keyId, agreement)\n                }\n\n            }\n\n        } \n      \n        return body\n    }\n    \n    static Map collectSigners(String emailStr,String parentId,Map agreeMap) {\n        String userAPIName = \"ContactObj\"\n        def (Boolean error, QueryResult data, String errorMessage) = Fx.object.find(userAPIName, //对象apiName\n                                                                          FQLAttribute.builder()\n                                                                                    .columns([\"_id\", \"name\",\"email\"]) //需要返回的字段\n                                                                                    .queryTemplate(QueryTemplate.AND([\"email\": QueryOperator.EQ(emailStr)])) //查询条件\n                                                                                    .build(),\n                                                                          SelectAttribute.builder()\n                                                                                    .needCalculate(true) //是否实时处理计算字段，默认true\n                                                                                    .needQuote(true) //是否实时处理引用字段，默认true\n                                                                                    .calculateCount(true) //是否实时处理统计字段，默认true\n                                                                                    .fillExtendInfo(false) //是否补充字段扩展信息，比如查找关联字段的主属性、人员部门名称等，以${字段apiName}__r返回，默认false\n                                                                                    .needOptionLabel(false) //是否返回单选、多选字段的label，以${字段apiName}__r返回，默认false\n                                                                                    .convertQuoteForView(false) //引用字段是否返回label，如果为true，引用字段的value通过${字段apiName}__v返回，默认false\n                                                                                    .needInvalid(false) //是否返回已作废的数据，默认false\n                                                                                    .needRelevantTeam(false) //是否返回相关团队，默认false\n                                                                                    .build())\n         if (error) {\n                log.error(\"获取对象异常\" + errorMessage)\n                return\n            } else {\n                log.info(\"I am here5\")\n                def dataList = data.dataList as List\n                String contactId = \"\"\n                dataList.each {\n                    e ->\n                        //dosomething，将示例逻辑细化至业务数据层\n                        def map = e as Map\n                        contactId = map['_id'] as String\n                }\n                // def contactId = map['_id'] as String\n                log.info(\"I am here6\")\n                Map mainData = Maps.newHashMap();\n                mainData.put(\"esignRec__c\", parentId);\n                mainData.put(\"sign_status__c\", agreeMap.status);\n                mainData.put(\"signer__c\", contactId);\n                Map detailData = [:];\n                def (Boolean error1, Map data1, String errorMessage1) = Fx.object.create(\"ESign_Report_Record__c\", mainData, detailData, CreateAttribute.builder().build())\n                \n                if (error1) {\n                    log.error(\"获取对象异常error1\" + errorMessage1)\n                    return\n                }\n                else {\n                    log.info(\"create mainData is : $data1\")\n                }\n                return data1\n            }\n    }\n    \n    //对外提供的方法\n    static String action() {\n        return \"sucesss\"\n    }\n\n    //debug 时候的入口方法\n    static void main(String[] args) {\n        \n        log.info(action()) \n\n    }\n\n}\n",
    "bindingObjectApiName": "NONE",
    "type": "class",
    "nameSpace": "library",
    "returnType": "",
    "tenantId": "67000207",
    "lang": 0
  },
  "class:ESignInfo": {
    "updateTime": 1767074664949,
    "name": "ESignInfo",
    "apiName": "ESignInfo__c",
    "content": "/**\n * @author 彭黄振Jame\n * @codeName ESignInfo\n * @description fetch ESign configuration\n * @createTime 2025-10-11\n * @bindingObjectLabel --\n * @bindingObjectApiName NONE\n * @函数需求编号\n */\n\n\n/**\n * @type classes\n * @returntype\n * @namespace library\n */\nclass ESignInfo {\n     /* 1. 外部可写的查询条件 */\n  public static String configName = 'Adobe Sign';\n  \n  // 缓存配置\n  // 2. 缓存：初始化为空 Map，避免 null\n  private static Map config = [:]\n\n  // 私有方法：加载配置\n  private static synchronized Map loadConfig() {\n    // 已经加载过（即使是空配置）就直接返回\n        if (config) return config\n        \n        def (Boolean error1, QueryResult queryResult, String errorMessage1) = Fx.object.find(\n          'ESignConfig__c',\n          FQLAttribute.builder()\n            .columns([\"_id\", \"name\", \"BaseUrl__c\", \"ClientID__c\", \"Securitykey__c\",\"isActive__c\",\"pem__c\",\"accountId__c\",\"auth_url__c\",\"userId__c\"])\n            .queryTemplate(\n              QueryTemplate.AND(\n                [\"name\": QueryOperator.EQ(configName)], [\"isActive__c\": QueryOperator.EQ(true)]\n              )\n            )\n            .build(),\n          SelectAttribute.builder()\n                  .needCalculate(true) //是否实时处理计算字段，默认true\n                  .needQuote(true) //是否实时处理引用字段，默认true\n                  .calculateCount(true) //是否实时处理统计字段，默认true\n                  .fillExtendInfo(false) //是否补充字段扩展信息，比如查找关联字段的主属性、人员部门名称等，以${字段apiName}__r返回，默认false\n                  .needOptionLabel(false) //是否返回单选、多选字段的label，以${字段apiName}__r返回，默认false\n                  .convertQuoteForView(false) //引用字段是否返回label，如果为true，引用字段的value通过${字段apiName}__v返回，默认false\n                  .needInvalid(false) //是否返回已作废的数据，默认false\n                  .needRelevantTeam(false) //是否返回相关团队，默认false\n                  .searchRichTextExtra(true)\n                  .build()\n        )\n  \n        if (error1) {\n          log.error(\"获取对象异常\" + errorMessage1)\n          config = [\n            signBaseURL: \"\",\n            baseURL    : \"\",\n            authURL    : \"\",\n            clientId    : \"\",\n            userId      : \"\",\n            accountId   : \"\",\n            key        : \"\",\n            pemKey     :\"\",\n            error: \"didnot find data\"\n          ]\n          log.info(config);\n          \n          return config\n        } else {\n          def dataList = queryResult.dataList as List //数据列表\n          def total = queryResult.total //符合条件的数据总条数\n          def size = queryResult.size  //本次返回的数据条数\n          dataList.each {\n                e ->\n                    //dosomething，将示例逻辑细化至业务数据层\n                    def map = e as Map\n                    \n                    config = [\n                      baseURL    : map[\"BaseUrl__c\"],\n                      authURL    : map[\"auth_url__c\"],\n                      clientId   : map[\"ClientID__c\"],\n                      userId     : map[\"userId__c\"],\n                      accountId  : map[\"accountId__c\"],\n                      key        : map[\"Securitykey__c\"],\n                      pemKey     : map[\"pem__c\"],\n                      error: \"\"\n                    ]\n                    log.info \"config:${config.baseURL}\"\n              \n            } \n          return config\n        }\n    \n  }\n\n    // 对外暴露的静态方法\n    static String getBaseURL()     { return loadConfig().baseURL }\n    static String getAuthURL()     { return loadConfig().authURL }\n    static String getClientId()     { return loadConfig().clientId }\n    static String getAccountId()     { return loadConfig().accountId }\n    static String getUserId()     { return loadConfig().userId }\n    static String getKey()         { return loadConfig().key }\n    static String getpemKey()         { return loadConfig().pemKey }\n    //对外提供的方法\n    static String action() {\n        return \"sucesss\"\n    }\n\n    //debug 时候的入口方法\n    static void main(String[] args) {\n        ESignInfo.configName = 'Adobe Sign'\n        log.info(\"baseURL: ${ESignInfo.getBaseURL()}\") \n        log.info(\"baseURL: ${ESignInfo.getClientId()}\")\n        log.info(\"key: ${ESignInfo.getKey()}\")\n    }\n\n}",
    "bindingObjectApiName": "NONE",
    "type": "class",
    "nameSpace": "library",
    "returnType": "",
    "tenantId": "67000207",
    "lang": 0
  },
  "class:ESTransientDocService": {
    "updateTime": 1767074664951,
    "name": "ESTransientDocService",
    "apiName": "ESTransientDocService__c",
    "content": "/**\n * @author 彭黄振Jame\n * @codeName TransientDocService\n * @description 上传文件到 Adobe Sign 拿到 transientDocumentId\n * @createTime 2025-10-11\n * @bindingObjectLabel --\n * @bindingObjectApiName NONE\n * @函数需求编号\n */\n\n\n/**\n * @type classes\n * @returntype\n * @namespace library\n */\nclass ESTransientDocService {\n    /**\n     * 上传文件到 Adobe Sign 拿到 transientDocumentId\n     * @param baseUrl  Adobe 根地址\n     * @param key      Bearer token\n     * @param filePath 文件在 FX 中的完整路径（serviceReport[0].path）\n     * @param nPath    文件名（带后缀，例如 \"test\" -> 实际用 \"test.pdf\"）\n     * @return  transientDocumentId 或 null\n     */\n    static String uploadAndGetTransientId(String baseUrl,\n                                          String key,\n                                          String filePath,\n                                          String nPath,\n                                          String uri) {\n\n        InputStream inputStream = Fx.file.downloadStream(filePath)[1]['inputStream'] as InputStream\n\n        String url = baseUrl + uri\n        // 一行搞定\n        List ret = HttpsService.postMultipart(url, key, nPath, inputStream) as List\n        Boolean error = ret[0] as Boolean\n        HttpResult result = ret[1] as HttpResult\n        String message = ret[2] as String\n    \n        if (error) {\n            log.info(\"TransientDocService error: \" + message)\n            return null\n        }\n        \n\n        Map jsonMap = Fx.json.parse(result[\"content\"] as String)\n        return jsonMap[\"transientDocumentId\"] as String\n    }\n    \n    /**\n     * 上传文件到 Docusign 拿到 transientDocumentId\n     * @param baseUrl  Adobe 根地址\n     * @param key      Bearer token\n     * @param filePath 文件在 FX 中的完整路径（serviceReport[0].path）\n     * @param nPath    文件名（带后缀，例如 \"test\" -> 实际用 \"test.pdf\"）\n     * @return  transientDocumentId 或 null\n     */\n    static String uploadAndGetDocusignTransientId(String baseUrl,\n                                          String key,\n                                          String filePath,\n                                          String nPath,\n                                          String uri,\n                                          Map envelopeJson) {\n\n        InputStream inputStream = Fx.file.downloadStream(filePath)[1]['inputStream'] as InputStream\n\n        String url = baseUrl + uri\n        // 一行搞定\n        List ret = HttpsService.postDocsignMultipart(url, key, nPath, inputStream,envelopeJson) as List\n        Boolean error = ret[0] as Boolean\n        HttpResult result = ret[1] as HttpResult\n        String message = ret[2] as String\n    \n        if (error) {\n            log.info(\"TransientDocService error: \" + message)\n            return null\n        }\n        \n        log.info \"TransientDocService result: $result\"\n        Map jsonMap = Fx.json.parse(result[\"content\"] as String)\n        return jsonMap[\"envelopeId\"] as String\n    }\n    //对外提供的方法\n    static String action() {\n        return \"sucesss\"\n    }\n\n    //debug 时候的入口方法\n    static void main(String[] args) {\n        String ret = action();\n        log.info(ret)\n    }\n\n}",
    "bindingObjectApiName": "NONE",
    "type": "class",
    "nameSpace": "library",
    "returnType": "",
    "tenantId": "67000207",
    "lang": 0
  },
  "class:ESAgreementService": {
    "updateTime": 1767074664954,
    "name": "ESAgreementService",
    "apiName": "ESAgreementService__c",
    "content": "/**\n * @author 彭黄振Jame\n * @codeName ESAgreementService\n * @description 提交Agreement服务\n * @createTime 2025-10-11\n * @bindingObjectLabel --\n * @bindingObjectApiName NONE\n * @函数需求编号\n */\n\n\n/**\n * @type classes\n * @returntype\n * @namespace library\n */\n\n\nclass ESAgreementService {\n/**\n     * 创建 Adobe Sign 协议\n     * @param signName       协议名称\n     * @param baseUrl        Adobe 根地址\n     * @param key            Bearer token\n     * @param transientId    上一步拿到的 transientDocumentId\n     * @param innerMail      内部员工邮箱\n     * @param innerName      内部员工姓名\n     * @param participantOuterSetsInfoList   外部联系人信息\n     * @return  agreementId 或 null\n     */\n    static String createAgreement(String signName,\n                                  String baseUrl,\n                                  String key,\n                                  String uri,\n                                  String transientId,\n                                  String innerMail,\n                                  String innerName,\n                                  List participantOuterSetsInfoList) {\n\n        // 1. 协议头\n        Map agreeMap = [\n            name          : signName,\n            signatureType : \"ESIGN\",\n            state         : \"IN_PROCESS\",\n            fileInfos     : [[transientDocumentId: transientId]]\n        ]\n\n        // 2. 内部签署人\n        List participantSetsInfoList = []\n        participantSetsInfoList << [\n            order       : \"1\",\n            role        : \"SIGNER\",\n            name        : innerName,\n            memberInfos : [[email: innerMail]]\n        ]\n\n        participantSetsInfoList.addAll(participantOuterSetsInfoList);\n        agreeMap[\"participantSetsInfo\"] = participantSetsInfoList\n        String url = baseUrl + uri;//\"/api/rest/v6/agreements\"\n        // --- 改成 List 接收，避开解构 ---\n        List postRet = HttpsService.postJson(url, key, agreeMap) as List\n        Boolean err       = postRet[0] as Boolean\n        HttpResult res    = postRet[1] as HttpResult\n        String msg        = postRet[2] as String\n        if (err) {\n            log.info(\"AgreementService error: \" + msg)\n            return null\n        }\n        Map jsonMap = Fx.json.parse(res[\"content\"] as String)\n        return jsonMap[\"id\"] as String\n    }\n    \n    //docusign 专属获得去签名的url\n    static String getDocusignAgreementURL(String baseUrl,String key, String uri, Map bodyMap){\n      String url = baseUrl+uri\n      log.info('url:'+url)\n      log.info \"body is : $bodyMap\"\n      StringBody body = StringBody.builder().content(bodyMap).build()\n      Request req = Request.builder()\n                           .method(\"POST\")\n                           .url(url)\n                           .timeout(75_000)\n                           .retryCount(0)\n                           .header(\"Content-Type\", \"application/json\")\n                           .header(\"Accept\", \"application/json\")\n                           .header(\"Authorization\", \"Bearer \" + key)\n                           .body(body)\n                           .build()\n                           \n      def(Boolean error, HttpResult result, String message) =Fx.http.execute(req)\n\n      if (error) {\n          log.error(\"http request error: \"+ error +\" errorMessage: \" + message + \" result: \" + result)\n          return null\n      }\n      \n      \n      String contentMap = result.content as String\n      Map xmap = Fx.json.parse(contentMap)\n      def tmpurl = xmap['url']\n      log.info \"url:$tmpurl\"\n      return tmpurl as String\n    }\n    \n    //Adobe 专属获得去签名的url\n    static String getAgreementURL(String baseUrl,\n                                  String key,\n                                  String uri,\n                                  String agreementId\n                                  ){\n      String url = baseUrl + uri + agreementId + \"/signingUrls\"\n      log.info('url:'+url)\n      // --- 同样改成 List 接收 ---\n      List getRet = HttpsService.getWithBearer(url, key) as List\n      Boolean error        = getRet[0] as Boolean\n      HttpResult fileResult = getRet[1] as HttpResult\n      String errorMessage   = getRet[2] as String\n\n      if (error) {\n          Fx.log.info(\"http 请求出错 ： \" + errorMessage)\n          return null\n      }\n      if (fileResult.statusCode != 200) {\n          Fx.log.info(\"http 响应错误 ：\" + fileResult.content)\n          return null\n      }\n      \n     \n      Map contentMap = fileResult[\"content\"] as Map\n      \n      List signingUrlSetInfoList = contentMap[\"signingUrlSetInfos\"] as List\n      \n      Map signingUrlsMap = signingUrlSetInfoList[0] as Map \n      \n      List signingUrlsList = signingUrlsMap[\"signingUrls\"] as List\n      \n      Map esignUrlMap = signingUrlsList[0] as Map\n      \n      return esignUrlMap[\"esignUrl\"] as String\n    }\n    \n    //获取签署完毕的URL\n    static String getAgreementSignedFileURL(\n                                            String baseUrl,\n                                            String key,\n                                            String uri,\n                                            String agreementId\n                                            ){\n                                              \n      String url = baseUrl + uri + agreementId + \"/combinedDocument/url\"\n      log.info('url:'+url)\n      \n      // --- 同样改成 List 接收 ---\n      List getRet = HttpsService.getWithBearer(url, key) as List\n      Boolean error        = getRet[0] as Boolean\n      HttpResult fileResult = getRet[1] as HttpResult\n      String errorMessage   = getRet[2] as String\n      if (error) {\n          Fx.log.info(\"http 请求出错 ： \" + errorMessage)\n          return null\n      }\n      if (fileResult.statusCode != 200) {\n          Fx.log.info(\"http 响应错误 ：\" + fileResult.content)\n          return null\n      }\n      \n      Map fileUrl = fileResult[\"content\"] as Map\n      \n      log.info(fileUrl)\n      \n      return fileUrl.url as String\n                                              \n    }\n    \n    //获取签署完毕的Docusign流文件\n    static Map getAgreementDocuSignedFileURL(\n                                            String baseUrl,\n                                            String key,\n                                            String uri,\n                                            String agreementId\n                                            ){\n                                              \n      String url = baseUrl + uri + \"/envelopes/\"+agreementId+\"/documents/combined\"\n      log.info('url:'+url)\n      \n      // Map map = [\"id\": agreementId, \"name\": \"协议\"]\n      // StringBody body = StringBody.builder().content(map).build()\n      \n      Request request = Request.builder()\n                        .method(\"GET\")\n                        .url(url)\n                        .timeout(7000)\n                        .retryCount(0)\n                        .header(\"Authorization\", \"Bearer \"+key)\n                        .header(\"Content-Type\", \"application/json\")\n                        .build()\n      def res = Fx.file.uploadFileByStream(request)\n      log.info(res)\n      \n      return res as Map\n                                              \n    }\n    \n    //获取签署完毕的Adobe流文件\n    static Map getAgreementAcrobatSignedFileURL(\n                                            String baseUrl,\n                                            String key,\n                                            String uri,\n                                            String agreementId\n                                            ){\n                                              \n      String url = baseUrl + uri + \"/agreements/\"+agreementId+\"/combinedDocument\"\n      log.info('url:'+url)\n      \n      Request request = Request.builder()\n                        .method(\"GET\")\n                        .url(url)\n                        .timeout(7000)\n                        .retryCount(0)\n                        .header(\"Authorization\", \"Bearer \"+key)\n                        .header(\"Accept\", \"application/pdf\")\n                        .build()\n      def res = Fx.file.uploadFileByStream(request)\n      log.info(res)\n      \n      return res as Map\n                                              \n    }\n    //对外提供的方法\n    static String action() {\n        return \"sucesss\"\n    }\n    \n    //debug 时候的入口方法\n    static void main(String[] args) {\n        String ret = action();\n        log.info(ret)\n    }\n\n}\n",
    "bindingObjectApiName": "NONE",
    "type": "class",
    "nameSpace": "library",
    "returnType": "",
    "tenantId": "67000207",
    "lang": 0
  },
  "class:DocuSignAuth": {
    "updateTime": 1767074664958,
    "name": "DocuSignAuth",
    "apiName": "DocuSignAuth__c",
    "content": "/**\n * @author 彭黄振Jame\n * @codeName DocuSignAuth\n * @description DocuSignAuth\n * @createTime 2025-10-28\n * @bindingObjectLabel --\n * @bindingObjectApiName NONE adb\n * @函数需求编号\n */\nimport fx.custom.apl.jar.JWTUtils\n\n\n/**\n * @type classes\n * @returntype\n * @namespace library aa\n */\nclass DocuSignAuth {\n  \n    // 设置 DocuSign 配置名称\n    private static String configName = 'Docusign'\n    private static Boolean refreshToken = false\n    \n    // 使用 ESignInfo 获取配置值\n    private static String getIss() { \n        String originalConfigName = ESignInfo.configName\n        ESignInfo.configName = configName\n        String clientId = ESignInfo.getClientId()\n        ESignInfo.configName = originalConfigName\n        return clientId\n    }\n    \n    private static String getSub() { \n        String originalConfigName = ESignInfo.configName\n        ESignInfo.configName = configName\n        String userId = ESignInfo.getUserId()\n        ESignInfo.configName = originalConfigName\n        return userId\n    }\n    \n    private static String getAud() { \n        String originalConfigName = ESignInfo.configName\n        ESignInfo.configName = configName\n        String authUrl = ESignInfo.getAuthURL()\n        ESignInfo.configName = originalConfigName\n        return authUrl\n    }\n    \n    private static String getScope() { \n        return \"signature impersonation\"\n    }\n    \n    private static String getAlg() { \n        return \"RS256\" \n    }\n    \n    private static String getCacheKey() { \n        return \"DocuSign_token\" \n    }\n    \n    private static String getDocusignAuthUrl() {\n        String audUrl = getAud()\n        log.info \"audUrl:${audUrl}/oauth/token\"\n        return \"${audUrl}/oauth/token\"\n    }\n    \n    // 获取私钥的方法\n    private static String getKeyPem() {\n        String originalConfigName = ESignInfo.configName\n        ESignInfo.configName = configName\n        String pemKey = ESignInfo.getpemKey()\n        ESignInfo.configName = originalConfigName\n        return pemKey\n    }\n  \n    // private static String iss = \"a305ecce-a390-422c-96f0-52d5e1cbd158\"\n    // private static String sub = \"f0d94e7b-946f-4ef6-841d-e945ee2b93d9\"\n    // private static String aud = \"account-d.docusign.com\"\n    // private static String scope = \"signature impersonation\"\n    // private static String alg = \"RS256\"\n    // private static String cacheKey = \"DocuSign_token\"\n    \n    // private static String docusignAuthUrl =\"https://\"+aud+\"/oauth/token\"\n    /**\n     * 无循环，顺序无关，保留换行\n     * 返回 Map[\"PUBLIC\":\"...\",\"PRIVATE\":\"...\"]\n     */\n    static Map<String, String> splitPem(String pem) {\n        Map<String, String> ans = new LinkedHashMap<String, String>()\n        if (pem == null) return ans\n    \n        /* 两个独立前瞻，各抓各的块，顺序任意 */\n        String regex = '(?s)(?=.*-----BEGIN PUBLIC KEY-----(.*?)-----END PUBLIC KEY-----)' +\n                       '(?=.*-----BEGIN RSA PRIVATE KEY-----(.*?)-----END RSA PRIVATE KEY-----)'\n        def m = pem =~ regex\n    \n        if (m.find()) {\n            ans.put('PUBLIC',\n                    '-----BEGIN PUBLIC KEY-----' + m.group(1) + '-----END PUBLIC KEY-----')\n            ans.put('PRIVATE',\n                    '-----BEGIN RSA PRIVATE KEY-----' + m.group(2) + '-----END RSA PRIVATE KEY-----')\n        }\n        return ans\n    }\n    \n    /**\n     * 向 DocuSign 账户服务器申请 JWT AccessToken\n     * @param privateKeyPem 完整的 RSA 私钥 PEM（含 -----BEGIN/END...）\n     * @return Map 成功返回 [\"access_token\":..., \"expires_in\":...]；失败返回 null\n     */\n    static String requestAccessToken(Map<String,Object> payload, String privateKeyPem, Integer expires, String alg) {\n        \n        def content\n        // 2. 生成 JWT\n        String token = JWTUtils.generateToken(payload, privateKeyPem, expires, alg)\n        if (token == null) {\n            log.error('JWT generate failed')\n            return null\n        }\n        log.info \"token:$token\"\n        // 3. 组装表单请求\n        FormBody body = FormBody.builder()\n                .field('grant_type', 'urn:ietf:params:oauth:grant-type:jwt-bearer')\n                .field('assertion', token)\n                .build()\n\n        Request request = Request.builder()\n                .method('POST')\n                .url(getDocusignAuthUrl())\n                .timeout(7000)\n                .retryCount(0)\n                .header('Content-Type', 'application/x-www-form-urlencoded')\n                .body(body)\n                .build()\n    \n        // 4. 执行请求\n        def(Boolean error, HttpResult result, String message) = Fx.http.execute(request)\n        if (error || result.statusCode != 200) {\n            //可以增加打印请求参数\n            log.error(\"http request error: \"+ error +\" errorMessage: \" + message + \" result: \" + result)\n\n        } else {\n          content = result.content as Map//函数封装的结果，一般使用这个即可\n          // log.info(\"result: \"+ result)\n          Integer expiresSecond = content[\"expires_in\"] as Integer\n          Long nowMillis = DateTime.now().toTimestamp()\n          if (nowMillis < 10_000_000_000L) nowMillis *= 1000\n          Long tokenExpireMillis = nowMillis + (expiresSecond - 30) * 1000\n          Map tokenMap = [:]\n          tokenMap.put(\"access_token\", content[\"access_token\"] as String)\n          tokenMap.put(\"token_type\", content[\"token_type\"] as String)\n          tokenMap.put(\"token_expires_millis\", tokenExpireMillis)\n          \n          Cache cache = Fx.cache.getDefaultCache()//将token放入本地缓存\n          String value = Fx.json.toJson(tokenMap)\n          cache.put(getCacheKey(), value, expiresSecond)\n          log.info(\"saveAccessToken2Cache key:\" + getCacheKey())\n        }\n        return content[\"access_token\"] as String\n    }\n    \n    static String getAccessToken(String privateKeyPem) {\n        Cache cache = Fx.cache.getDefaultCache()\n        log.info \"current cache :${cache}\"\n        String value = cache.get(getCacheKey()) as String//从本地缓存取出token\n        String accessToken = \"\"\n        if(refreshToken || value == null){\n            // log.info(\"getAccessTokenFromCache key:\" + getCacheKey() )\n            // log.info(\"value is null refreshToken:\" + refreshToken )\n            accessToken = getRefreshToken(privateKeyPem)\n            log.info(\"get New AccessToken for value null:\" +accessToken)\n            return accessToken\n        }\n        Map tokenMap = Fx.json.parse(value)\n        accessToken = tokenMap[\"access_token\"] as String\n        Long expired = tokenMap[\"token_expires_millis\"] as Long\n        log.info(\"getAccessTokenFromCache key:\" + accessToken)\n        \n        if(expired <= DateTime.now().toTimestamp()){\n            \n            accessToken = getRefreshToken(privateKeyPem)\n            log.info(\"get New AccessToken for expired:\" +accessToken)\n        }\n        \n  \n        return accessToken\n    }\n    \n    static String getRefreshToken (String privateKeyPem) {\n          Map<String, Object> payload = new LinkedHashMap<String, Object>()\n          payload.put('iss', getIss())        // Integrator Key\n          payload.put('sub', getSub())        // UserId\n          payload.put('aud', getAud().replace(\"https://\", \"\"))\n          payload.put('scope', getScope())\n          String accessToken = requestAccessToken(payload, privateKeyPem,6000,getAlg())\n          return accessToken\n    }\n    \n    static String getAccessToken() {\n      String keyStr = getKeyPem()\n      // log.info \"keyStr:$keyStr\"\n      Map<String, String> keys = splitPem(keyStr)\n      String privateKeyPem = keys.get('PRIVATE')\n      // log.info \"privateKeyPem:$privateKeyPem\"\n      return getAccessToken(privateKeyPem)\n    }\n    //对外提供的方法\n    static String action() {\n        return \"sucesss\"\n    }\n\n    //debug 时候的入口方法\n    static void main(String[] args) {\n      // refreshToken = true\n      String key = getAccessToken()\n      log.info \"Access Token key: $key\"\n\n      \n    }\n\n}",
    "bindingObjectApiName": "NONE",
    "type": "class",
    "nameSpace": "library",
    "returnType": "",
    "tenantId": "67000207",
    "lang": 0
  },
  "class:ClassUtils": {
    "updateTime": 1767074664960,
    "name": "ClassUtils",
    "apiName": "ClassUtils__c",
    "content": "/**\n * @author 彭黄振Jame\n * @codeName ClassUtils\n * @description Class Utils\n * @createTime 2025-10-22\n * @bindingObjectLabel --\n * @bindingObjectApiName NONE\n * @函数需求编号\n */\n\n\n/**\n * @type classes\n * @returntype\n * @namespace library\n */\n@groovy.transform.CompileStatic\nclass ClassUtils {\n    \n    /** 静态编译：只负责拿到 Class */\n    static Class<?> classForName(String clsName) {\n\n        String targetName = 'fx.custom.apl.script.' + clsName\n        // 任意“已加载”的类当锚点\n        def anchorClass = this // 拿去当前类的基本属性\n        def cl = anchorClass.getClassLoader() // 不会触发 CPS 黑名单\n        def targetClass = cl.loadClass(targetName)//获取定义类\n        return targetClass as Class // 字段访问，安全\n    }\n    /** 动态编译：一次封装，处处可用 */\n    // @groovy.transform.CompileDynamic\n    static Object invokeStatic(String clsName, String methodName, Object... args) {\n        Class<?> clazz = classForName(clsName)\n        def util = ClassUtils.newInstance(clsName)\n        Class[] paramTypes = args.collect { it?.class } as Class[]\n        return clazz.getDeclaredMethod(methodName, paramTypes)\n                    .invoke(util, args)\n    }\n    \n    /* 下面这两个方法同样动态，调用者仍无需注解 */\n    static Object invoke(String clsName, String methodName, Object instance, Object... args) {\n        Class<?> clazz = classForName(clsName)\n        Class[] paramTypes = args.collect { it?.class } as Class[]\n        return clazz.getDeclaredMethod(methodName, paramTypes)\n                    .invoke(instance, args)\n    }\n    \n    /* 快速 new 实例 */\n    static Object newInstance(String clsName, Object... args) {\n        Class<?> clazz = classForName(clsName)\n        Class[] paramTypes = args.collect { it?.class } as Class[]\n        return clazz.getDeclaredConstructor(paramTypes)\n                    .newInstance(args)\n    }\n    \n    //对外提供的方法\n    static String action() {\n        return \"sucesss\"\n    }\n\n    //debug 时候的入口方法\n    static void main(String[] args) {\n        def id = ClassUtils.invokeStatic('ShortSnowflakeIdUtil', 'nextId')\n        log.info(id)\n        // 实例方法同理\n        def util = ClassUtils.newInstance('ShortSnowflakeIdUtil')\n        // log.info(util.getDeclaredMethod('nextId').invoke(null))\n        def id2  = ClassUtils.invoke('ShortSnowflakeIdUtil', 'nextId', util)\n        log.info(id2)\n    }\n\n}\n",
    "bindingObjectApiName": "NONE",
    "type": "class",
    "nameSpace": "library",
    "returnType": "",
    "tenantId": "67000207",
    "lang": 0
  },
  "class:CertTokenUtils": {
    "updateTime": 1767074664962,
    "name": "CertTokenUtils",
    "apiName": "CertTokenUtils__c",
    "content": "/**\n * 证书令牌工具类\n * 功能：生成包含摘要、压缩原文、盐值和校验码的安全令牌\n * 令牌格式：12位摘要 + 14位压缩原文 + 6位盐 + 2位计数 + 8位校验码 = 42字符\n */\nclass CertTokenUtils {\n    // 计数器，用于生成唯一序列\n    private static int COUNTER = 0\n    \n    // 存储原始内容的映射，key为12位摘要，value为原始Base64字符串\n    private static Map<String, String> originalMap = new HashMap<>()\n\n    /**\n     * 1. 编码方法：生成42字符的安全令牌\n     * 令牌结构：12位摘要 + 14位压缩原文 + 6位时间盐 + 2位计数器 + 8位校验码\n     * @param rawBase64 原始Base64字符串\n     * @return 42字符的安全令牌\n     */\n    static String encode(String rawBase64) {\n        // ① 摘要计算：使用SHA-256生成哈希，取前12位36进制作为摘要标识\n        byte[] hash32 = java.security.MessageDigest.getInstance(\"SHA-256\").digest(rawBase64.getBytes())\n        String hash36 = bytesToHex(hash32)          // 将字节数组转换为十六进制字符串\n        String idx12  = hash36.substring(0, 12)     // 取前12位作为摘要标识\n    \n        // ② 压缩原文：将原始Base64编码并截取前14位，不足补'A'\n        String comp14 = java.util.Base64.getUrlEncoder()\n                                      .encodeToString(rawBase64.getBytes())  // Base64URL编码\n                                      .substring(0, Math.min(14, rawBase64.length()))  // 截取前14位\n                                      .padRight(14, 'A')        // 不足14位时右侧补'A'\n    \n        // ③ 盐值 + 校验码生成\n        String time = Long.toString(System.currentTimeMillis(), 36).substring(0, 6)  // 当前时间戳的36进制，取前6位\n        String cnt  = padTwo(Long.toString((nextCounter() & 0xFF), 36))              // 2位计数器，36进制\n        String salt = time + cnt                                                     // 组合成8位盐值(6位时间+2位计数)\n        \n        // 校验码计算：摘要与盐值异或后取低33位，转为8位36进制\n        long mix = Long.parseLong(idx12, 36) ^ Long.parseLong(salt, 36)              // 摘要与盐值异或\n        String check = padEight(Long.toString(mix & 0x1FFFFFFFFL, 36))               // 取低33位并补零到8位\n    \n        // 组合生成完整令牌：12位摘要 + 14位压缩原文 + 8位盐值 + 8位校验码 = 42字符\n        String token = idx12 + comp14 + salt + check\n        \n        // 存储原始内容到映射，后续解码时使用\n        originalMap.put(idx12, rawBase64)\n        \n        return token\n    }\n\n    /**\n     * 2. 解码方法：从令牌中还原原始Base64字符串\n     * 优先从内存映射中获取，映射不存在时降级到解码压缩版本\n     * @param token 42字符的安全令牌\n     * @return 原始Base64字符串，解码失败返回空字符串\n     */\n    static String decode(String token) {\n        // 基础校验：令牌长度必须至少42字符\n        if (token == null || token.length() < 42) {\n            return \"\"\n        }\n        \n        try {\n            // 提取令牌前12位作为摘要标识\n            String idx12 = token.substring(0, 12)\n            \n            // 优先从内存映射中获取原始内容（确保返回完整原始数据）\n            String original = originalMap.get(idx12)\n            if (original != null) {\n                return original\n            }\n            \n            // 降级方案：如果映射中不存在，解码压缩的Base64部分\n            // 注意：这可能返回被截断的内容，因为编码时只保留了前14位\n            String comp14 = token.substring(12, 26)  // 提取14位压缩原文\n            byte[] decodedBytes = java.util.Base64.getUrlDecoder().decode(comp14)  // Base64URL解码\n            return new String(decodedBytes)\n        } catch (Exception e) {\n            e.printStackTrace()\n            return \"\"\n        }\n    }\n\n    /**\n     * 3. 验证方法：校验令牌的完整性和真实性\n     * 通过重新计算校验码并与令牌中的校验码对比来验证\n     * @param token 42字符的安全令牌\n     * @return 验证通过返回true，否则返回false\n     */\n    static boolean verify(String token) {\n        try {\n            // 基础校验：令牌必须恰好42字符\n            if (token == null || token.length() != 42) {\n                return false\n            }\n            \n            // 提取令牌各组成部分\n            String idx12 = token.substring(0, 12)           // 前12位：摘要标识\n            String salt = token.substring(26, 34)           // 第27-34位：盐值(6位时间+2位计数)\n            String chk = token.substring(34, 42)            // 第35-42位：校验码\n            \n            // 重新计算校验码：使用相同的算法\n            long mix = Long.parseLong(idx12, 36) ^ Long.parseLong(salt, 36)      // 摘要与盐值异或\n            String calculatedCheck = padEight(Long.toString(mix & 0x1FFFFFFFFL, 36))  // 计算8位校验码\n            \n            // 比较计算出的校验码与令牌中的校验码是否一致\n            return calculatedCheck.equals(chk)\n        } catch (Exception e) { \n            e.printStackTrace()\n            return false \n        }\n    }\n\n    /**\n     * 清理方法：从内存映射中移除令牌对应的原始内容\n     * 防止内存泄漏，建议在使用完令牌后调用\n     * @param token 要清理的令牌\n     */\n    static void cleanup(String token) {\n        if (token != null && token.length() >= 12) {\n            originalMap.remove(token.substring(0, 12))  // 使用摘要标识作为key进行移除\n        }\n    }\n\n    /**\n     * 4. 对外接口方法\n     * @return 固定返回\"success\"字符串\n     */\n    static String action() { return \"success\" }\n\n    /* ====== 内部工具方法 ====== */\n    \n    /**\n     * 计数器递增方法\n     * 每次调用计数器加1，并限制在0xFFFFFF范围内\n     * @return 更新后的计数器值\n     */\n    private static int nextCounter() { return COUNTER = (COUNTER + 1) & 0xFFFFFF }\n\n    /**\n     * DJB哈希算法：递归实现的无循环哈希函数\n     * @param data 输入字节数组\n     * @param idx 当前处理索引\n     * @param h 当前哈希值\n     * @return 计算完成的哈希值\n     */\n    private static long djb(byte[] data, int idx, long h) {\n        return idx >= data.length ? h : djb(data, idx + 1, ((h << 5) + h + (data[idx] & 0xFF)) & 0x7FFFFFFFL)\n    }\n\n    /**\n     * 补零工具方法：确保字符串至少2位长度\n     * @param s 输入字符串\n     * @return 补零后的2位字符串\n     */\n    private static String padTwo(String s)  { return s.length() >= 2 ? s : \"0\" + s }\n    \n    /**\n     * 补零工具方法：确保字符串至少8位长度\n     * @param s 输入字符串\n     * @return 补零后的8位字符串\n     */\n    private static String padEight(String s){ return s.length() >= 8 ? s : String.format(\"%0\" + (8 - s.length()) + \"d%s\", 0, s) }\n\n    /* 5. 十六进制转换工具 */\n    \n    /**\n     * 字节数组转十六进制字符串\n     * 使用Stream API实现无循环转换\n     * @param bytes 输入字节数组\n     * @return 十六进制字符串\n     */\n    private static String bytesToHex(byte[] bytes) {\n        return java.util.stream.IntStream.range(0, bytes.length)\n                                  .mapToObj(new java.util.function.IntFunction<String>() {\n                                      @Override\n                                      String apply(int i) {\n                                          return byteToHex(bytes[i]);\n                                      }\n                                  })\n                                  .collect(java.util.stream.Collectors.joining());\n    }\n    \n    /**\n     * 单字节转十六进制字符串\n     * @param b 输入字节\n     * @return 2位十六进制字符串（大写）\n     */\n    private static String byteToHex(byte b) {\n        return Integer.toHexString(b & 0xFF).toUpperCase();\n    }\n\n    /**\n     * 6. 测试方法：验证编码、解码、验证功能的正确性\n     */\n    static void main(String[] args) {\n        // 测试用的长Base64字符串\n        String raw = 'ZXlKaGJHY2lPaUpJVXpJMU5pSXNJblI1Y0NJNklrcFhWQ0o5LmV5SnpkV0lpT2lKU1pYRjFaWE4wVkc5clpXNGlMQ0pwYzNNaU9pSkRSVkF0VTJWeWRtVnlJaXdpWlc1MFpYSndjbWx6WlVGalkyOTFiblFpT2lKbWEzUmxjM1E0TlRFNUlpd2laVzUwWlhKd2NtbHpaVWxrSWpvMk56QXdNREl3Tnl3aWMyVnpjMmx2Ymtsa0lqb2lOMlZsTVdKa01qWXRNalV6T1MwME16RTJMVGd6TURJdE5qZzNaakUzT1RBeU1EZzJJaXdpWlhod0lqb3pPRE0yTURBek1UZ3pMQ0oxYzJWeVNXUWlPakV3TURBc0ltbGhkQ0k2TVRjMk1ETXlNVEk1TW4wLjZUcDc0RF9hZlJRWTlZOVRQdFl5UUJXaWVDQ1lFaUtaWVNQUVp1d3dNR2M='\n        \n        // 编码测试\n        def t = encode(raw)\n        log.info(\"Token: \" + t)\n        \n        // 解码测试\n        log.info(\"Decoded: \" + decode(t))\n        \n        // 验证测试\n        log.info(\"Verify: \" + verify(t))\n        \n        // 清理测试\n        cleanup(t)\n    }\n}",
    "bindingObjectApiName": "NONE",
    "type": "class",
    "nameSpace": "library",
    "returnType": "",
    "tenantId": "67000207",
    "lang": 0
  },
  "class:AdobeWebhookController": {
    "updateTime": 1767074664964,
    "name": "AdobeWebhookController",
    "apiName": "AdobeWebhookController__c",
    "content": "/**\n * @author 彭黄振Jame\n * @codeName Adobe Webhook Controller\n * @description Adobe Webhook Controller\n * @createTime 2025-10-16\n * @bindingObjectLabel --\n * @bindingObjectApiName NONE\n * @函数需求编号\n */\n\n\n/**\n * @type classes\n * @returntype\n * @namespace library\n */\n/**\n * @author 彭黄振Jame\n * @codeName WebHookController\n * @description WebHookController\n * @createTime 2025-10-13\n * @bindingObjectLabel --\n * @bindingObjectApiName NONE\n * @函数需求编号\n */\n\n\n/**\n * @type classes\n * @returntype\n * @namespace apl_controller\n */\n@AplController(baseUrl = \"/apl\")\nclass AdobeWebhookController {\n    \n    @AplRequestMapping(value = \"/postmethod\", method = RequestMethod.POST)\n    public HttpResponse query(HttpRequest request) {\n        String requestBody = new String(request.getBody(), \"UTF-8\")\n        log.info(requestBody)\n        Map returnBody = ESignReceivedService.getESignReceived(requestBody) as Map\n        // Map returnBody = [\"status\": 200, \"data\": \"ook\", \"message\": \"success!\",\"xAdobeSignClientId\":\"UB7E5BXCXY\"]\n        String body = Fx.json.toJson(returnBody)\n        return HttpResponse.ok()\n                .header(\"Content-Type\", \"application/json\")\n                .header(\"x-adobesign-clientid\", \"UB7E5BXCXY\")\n                // .header(\"x-adobesign-clientid\", \"ats-1e6bdecd-7ca6-4e5f-9ef6-05068f29712d\")\n                .body(body)\n    }\n    \n    @AplRequestMapping(value = \"/getmethod\", method = RequestMethod.POST)\n    public HttpResponse getmethod(HttpRequest request) {\n        String requestBody = new String(request.getBody(), \"UTF-8\")\n        log.info(\"request body: \" + requestBody)\n        Map returnBody = [\"xAdobeSignClientId\":\"UB7E5BXCXY\",\"status\":200]\n        String body = Fx.json.toJson(returnBody)\n        return HttpResponse.ok()\n                .header(\"Content-Type\", \"application/json\")\n                .header(\"x-adobesign-clientid\", \"UB7E5BXCXY\")\n                .body(body)\n    }\n\n    /**\n     * 硬编码方法：获取AplRequestMapping路径映射\n     * @return Map<String, String> 方法名到路径的映射\n     */\n    public Map<String, String> getAplRequestMappingPaths() {\n        Map<String, String> pathMapping = [:]\n        \n        // 硬编码添加所有AplRequestMapping的路径\n        pathMapping.put(\"POST\", \"/apl/postmethod\")\n        pathMapping.put(\"GET\", \"/apl/getmethod\")\n        \n        return pathMapping\n    }\n\n    public void debug(FunctionContext context, Map<String, Object> args) {\n      \n        \n        Map headers = [\n                \"Content-Type\": [\"application/json\"]\n        ]\n        Map parameters = [\n                \"name\": [\"zhangsan\"]\n        ]\n        byte[] body = [1, 2, 3] as byte[]\n        HttpRequest request = new HttpRequest(headers, parameters, body)\n        def clz = ClassUtils.invokeStatic('AdobeWebhookController', 'postmethod',request)\n        // log.info(Fx.json.toJson(query(request)))\n        log.info(Fx.json.toJson(clz))\n        \n        // 测试获取路径映射\n        log.info(\"AplRequestMapping Paths: \" + Fx.json.toJson(getAplRequestMappingPaths()))\n        \n        // request = new HttpRequest(headers, parameters, body)\n        // log.info(\"====result: \" + Fx.json.toJson(getMethod(request)))\n    }\n}\n",
    "bindingObjectApiName": "NONE",
    "type": "class",
    "nameSpace": "library",
    "returnType": "",
    "tenantId": "67000207",
    "lang": 0
  }
}