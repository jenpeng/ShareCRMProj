{
  "Result": {
    "FailureCode": 0,
    "StatusCode": 0,
    "UserInfo": {
      "EmployeeID": 1000,
      "EnterpriseAccount": "fktest8519"
    }
  },
  "Value": {
    "list": [
      {
        "name": "WebHookController",
        "apiName": "WebHookController__c",
        "content": "/**\n * @author 彭黄振Jame\n * @codeName WebHookController\n * @description WebHookController\n * @createTime 2025-10-13\n * @bindingObjectLabel --\n * @bindingObjectApiName NONE\n * @函数需求编号\n */\n\n\n/**\n * @type classes\n * @returntype\n * @namespace apl_controller\n */\n@AplController(baseUrl = \"/apl\")\nclass WebHookController {\n\n    @AplRequestMapping(value = \"/query\", method = RequestMethod.POST)\n    public HttpResponse query(HttpRequest request) {\n        String requestBody = new String(request.getBody(), \"UTF-8\")\n        log.info(requestBody)\n\n        Map returnBody = [\"code\": 0, \"data\": \"ook\", \"message\": \"success!\"]\n        String body = Fx.json.toJson(returnBody)\n        return HttpResponse.ok()\n                .header(\"Content-Type\", \"application/json\")\n                .body(body)\n    }\n    \n    // @AplRequestMapping(value = \"/getmethod\", method = RequestMethod.GET)\n    // public HttpResponse getMethod(HttpRequest request) {\n    //     String requestBody = new String(request.getBody(), \"UTF-8\")\n    //     log.info(requestBody)\n    //\n    //     Map returnBody = [\"xAdobeSignClientId\":\"ats-1e6bdecd-7ca6-4e5f-9ef6-05068f29712d\"]\n    //     String body = Fx.json.toJson(returnBody)\n    //     return HttpResponse.ok()\n    //             .header(\"Content-Type\", \"application/json\")\n    //             .body(body)\n    // }\n\n    /**\n     * 硬编码方法：获取AplRequestMapping路径映射\n     * @return Map<String, String> 方法名到路径的映射\n     */\n    public Map<String, String> getAplRequestMappingPaths() {\n        Map<String, String> pathMapping = [:]\n        \n        // 硬编码添加所有AplRequestMapping的路径\n        pathMapping.put(\"query\", \"/apl/query\")\n        pathMapping.put(\"getMethod\", \"/apl/getmethod\")\n        \n        return pathMapping\n    }\n\n    public void debug(FunctionContext context, Map<String, Object> args) {\n        Map headers = [\n                \"Content-Type\": [\"application/json\"]\n        ]\n        Map parameters = [\n                \"name\": [\"zhangsan\"]\n        ]\n        byte[] body = [1, 2, 3] as byte[]\n        HttpRequest request = new HttpRequest(headers, parameters, body)\n        log.info(Fx.json.toJson(query(request)))\n        \n        // 测试获取路径映射\n        log.info(\"AplRequestMapping Paths: \" + Fx.json.toJson(getAplRequestMappingPaths()))\n        \n        // request = new HttpRequest(headers, parameters, body)\n        // log.info(\"====result: \" + Fx.json.toJson(getMethod(request)))\n    }\n}",
        "updateTime": 1766979119183,
        "bindingObjectApiName": "NONE",
        "type": "class",
        "nameSpace": "apl_controller",
        "tenantId": "67000207",
        "lang": 0
      },
      {
        "name": "Triggers",
        "apiName": "Triggers__c",
        "content": "/**\n * @author 彭黄振Jame\n * @codeName Triggers\n * @description Triggers handlers使用\n * @createTime 2025-10-11\n * @bindingObjectLabel --\n * @bindingObjectApiName NONE\n * @函数需求编号\n */\n\n\n/**\n * @type classes\n * @returntype\n * @namespace library\n */\nclass Triggers {\n  \n    interface Handler { void handle() }\n\n    private List<Triggers.Handler> handlers = []\n\n    Triggers bind(Triggers.Handler h) {\n        if (h) handlers << h\n        return this\n    }\n\n    Triggers bind(Closure c) {\n        if (c) handlers << ({ -> c() } as Triggers.Handler)   // 包一层\n        return this\n    }\n\n    void manage() { handlers.each { it.handle() } }\n\n    //对外提供的方法\n    static String action() {\n        return \"sucesss\"\n    }\n\n    //debug 时候的入口方法\n    static void main(String[] args) {\n        String ret = action();\n        log.info(ret)\n    }\n\n}\n",
        "updateTime": 1766979116693,
        "bindingObjectApiName": "NONE",
        "type": "class",
        "nameSpace": "library",
        "tenantId": "67000207",
        "lang": 0
      },
      {
        "name": "ShortSnowflakeIdUtil",
        "apiName": "ShortSnowflakeIdUtil__c",
        "content": "/**\n * @author 彭黄振Jame\n * @codeName ShortSnowflakeIdUtil\n * @description 20位以内短雪花ID（无位运算、无循环，APL兼容）\n * @createTime 2025-10-19\n * @bindingObjectLabel --\n * @bindingObjectApiName NONE\n * @函数需求编号\n */\n\n/**\n * @type classes\n * @returntype String\n * @namespace library\n */\nclass ShortSnowflakeIdUtil {\n\n    /*========== 可外部注入的参数 ==========*/\n    private static Long workerId     = 1L   // 0~31\n    private static Long datacenterId = 1L   // 0~31\n\n    /*========== 常量 ==========*/\n    private static Long TWPOCH = 1420041600000L   // 2015-01-01 00:00:00\n    private static Long SEQUENCE_BITS  = 12L\n    private static Long WORKER_BITS    = 5L\n    private static Long DATACENTER_BITS= 5L\n\n    private static Long MAX_SEQUENCE   = 4095L      // 2^12-1\n    private static Long MAX_WORKER     = 31L        // 2^5-1\n    private static Long MAX_DATACENTER = 31L        // 2^5-1\n\n    /*========== 运行时变量 ==========*/\n    private static Long sequence  = 0L\n    private static Long lastTime  = -1L\n\n    /*========== 对外 API ==========*/\n    /** 生成下一个全局唯一ID（字符串） */\n    public static String nextId() {\n        return generateId()\n    }\n\n    /*========== 私有实现 ==========*/\n    private static synchronized String generateId() {\n        Long now = System.currentTimeMillis()\n        if (now < lastTime) {\n            log.info(\"Clock moved backwards\")\n        }\n\n        if (now == lastTime) {\n            sequence = sequence + 1\n            if (sequence > MAX_SEQUENCE) {\n                // 序列耗尽，直接等到下一毫秒（APL不支持while，用递归代替）\n                return waitNextMillis(lastTime)\n            }\n        } else {\n            sequence = 0\n        }\n\n        lastTime = now\n\n        /* 代替位运算的乘加拼装 */\n        Long timePart  = (now - TWPOCH) * 4194304L          // 左移22位：2^(5+5+12)\n        Long dataPart  = datacenterId * 131072L             // 左移17位：2^(5+12)\n        Long workPart  = workerId     * 4096L               // 左移12位\n        Long id = timePart + dataPart + workPart + sequence\n\n        return id.toString()\n    }\n\n    /** 递归等待下一毫秒（替代while） */\n    private static String waitNextMillis(Long last) {\n        Long t = System.currentTimeMillis()\n        if (t <= last) {\n            // 仍没越过上一毫秒，继续递归\n            return waitNextMillis(last)\n        }\n        // 时间已更新，重新生成ID\n        return generateId()\n    }\n\n    /*========== 调试入口 ==========*/\n    static void main(String[] args) {\n        log.info(\"ShortSnowflakeIdUtil test => \" + nextId())\n        def str = '{\"baseurl\":\"https://www.fxiaoke.com\",\"method\":{\"POST\":\"/postmethod\",\"GET\":\"/getmethod\"},\"cert\":\"ZXlKaGJHY2lPaUpJVXpJMU5pSXNJblI1Y0NJNklrcFhWQ0o5LmV5SnpkV0lpT2lKU1pYRjFaWE4wVkc5clpXNGlMQ0pwYzNNaU9pSkRSVkF0VTJWeWRtVnlJaXdpWlc1MFpYSndjbWx6WlVGalkyOTFiblFpT2lKbWEzUmxjM1E0TlRBM0lpd2laVzUwWlhKd2NtbHpaVWxrSWpvNE1qUXpNRElzSW5ObGMzTnBiMjVKWkNJNklqWTRZMk14TTJZNExUZ3lNVEV0TkRnd01TMDRNVEkwTFdKaFlqSm1NR0prTTJJNE55SXNJbVY0Y0NJNk16Z3pOVFE0TWpJME15d2lkWE5sY2tsa0lqb3hNREF3TENKcFlYUWlPakUzTmpBd05qQTRNakY5LjNQcC14MTB2TmJFYUpzZ3ZBQTJzZmc5Zk5RV09sWjhUTGFtY2cyaEpuYjA=\"}'\n        def encode1 = Fx.crypto.MD5.encode(str)\n        log.info(\"MD5 test => \" +encode1)\n    }\n}",
        "updateTime": 1766979114261,
        "bindingObjectApiName": "NONE",
        "type": "class",
        "nameSpace": "library",
        "tenantId": "67000207",
        "lang": 0
      },
      {
        "name": "NewTestClass2",
        "apiName": "NewTestClass2__c",
        "content": "//demo\nclass NewTestClass2 {\n  \n  //对外提供的方法\n  public static String action(){\n    return \"success\"\n  }\n  \n  //debug 时候的入口方法\n  public static void main(String[] args){\n    String ret = action();\n    log.info(ret)\n  }\n  \n}\n",
        "updateTime": 1766979111844,
        "bindingObjectApiName": "NONE",
        "type": "class",
        "nameSpace": "library",
        "tenantId": "67000207",
        "lang": 0
      },
      {
        "name": "NewTestClass",
        "apiName": "NewTestClass__c",
        "content": "//demo\nclass NewTestClass {\n  \n  //对外提供的方法\n  public static String action(){\n    return \"success\"\n  }\n  \n  //debug 时候的入口方法\n  public static void main(String[] args){\n    String ret = action();\n    log.info(ret)\n  }\n  \n}\n",
        "updateTime": 1766979109435,
        "bindingObjectApiName": "NONE",
        "type": "class",
        "nameSpace": "library",
        "tenantId": "67000207",
        "lang": 0
      },
      {
        "name": "NewTestAgainClass",
        "apiName": "NewTestAgainClass__c",
        "content": "//demo\nclass NewTestAgainClass {\n  \n  //对外提供的方法\n  public static String action(){\n    return \"success\"\n  }\n  \n  //debug 时候的入口方法\n  public static void main(String[] args){\n    String ret = action();\n    log.info(ret)\n  }\n  \n}\n",
        "updateTime": 1766979107047,
        "bindingObjectApiName": "NONE",
        "type": "class",
        "nameSpace": "library",
        "tenantId": "67000207",
        "lang": 0
      },
      {
        "name": "MyTestClass",
        "apiName": "MyTestClass__c",
        "content": "//demo\nclass MyTestClass {\n  \n  //对外提供的方法\n  public static String action(){\n    return \"success\"\n  }\n  \n  //debug 时候的入口方法\n  public static void main(String[] args){\n    String ret = action();\n    log.info(ret)\n  }\n  \n}\n",
        "updateTime": 1766979104454,
        "bindingObjectApiName": "NONE",
        "type": "class",
        "nameSpace": "library",
        "tenantId": "67000207",
        "lang": 0
      },
      {
        "name": "MyLibraryClass",
        "apiName": "MyLibraryClass__c",
        "content": "//demo\nclass MyLibraryClass {\n  \n  //对外提供的方法\n  public static String action(){\n    return \"success\"\n  }\n  \n  //debug 时候的入口方法\n  public static void main(String[] args){\n    String ret = action();\n    log.info(ret)\n  }\n  \n}\n",
        "updateTime": 1766979101728,
        "bindingObjectApiName": "NONE",
        "type": "class",
        "nameSpace": "library",
        "tenantId": "67000207",
        "lang": 0
      },
      {
        "name": "MyHandler",
        "apiName": "MyHandler__c",
        "content": "/**\n * @author 彭黄振Jame\n * @codeName MyHandler\n * @description MyHandler\n * @createTime 2025-10-11\n * @bindingObjectLabel --\n * @bindingObjectApiName NONE\n * @函数需求编号\n */\n\n\n/**\n * @type classes\n * @returntype\n * @namespace library\n */\nclass MyHandler implements Triggers.Handler {\n  \n    private String tag\n    MyHandler(String tag) { this.tag = tag }\n    void handle() { \n      log.info(\"my handler: \" + tag)\n      println \"my handler [$tag]\" \n      \n    }\n\n    //对外提供的方法\n    static String action() {\n        return \"sucesss\"\n    }\n\n    //debug 时候的入口方法\n    static void main(String[] args) {\n        def t = new Triggers()\n        t.bind(new MyHandler('A'))\n         .bind(new MyHandler('B'))\n         .manage()\n    }\n\n}\n",
        "updateTime": 1766979099311,
        "bindingObjectApiName": "NONE",
        "type": "class",
        "nameSpace": "library",
        "tenantId": "67000207",
        "lang": 0
      },
      {
        "name": "LoopUtilsTestClass",
        "apiName": "LoopUtilsTestClass__c",
        "content": "/**\n * @author 彭黄振Jame\n * @codeName AAATest\n * @description AAATest\n * @createTime 2025-10-25\n * @bindingObjectLabel --\n * @bindingObjectApiName NONE\n * @函数需求编号\n */\nimport fx.custom.apl.jar.LoopUtils\n\n/**\n * @type classes\n * @returntype\n * @namespace library\n */\nclass LoopUtilsTestClass {\n\n    //对外提供的方法\n    static String action() {\n        return \"sucesss\"\n    }\n\n    //debug 时候的入口方法\n    static void main(String[] args) {\n        log.info \"=== Groovy调用LoopUtils示例 ===\"\n        \n        // 1. 标准for循环示例\n        log.info \"[1. 标准for循环示例 (0到9)]：\"\n        LoopUtils.forLoop(0, 10, 1) { i ->\n            log.info \"$i \"\n        }\n        \n        // 示例1: for循环中使用breakLoop()方法 - 无需return或throw\n        log.info \"[1. for循环中使用breakLoop()]:\"\n        LoopUtils.forLoop(0, 10, 1, { int i ->\n            log.info \"  循环: $i\"\n            if (i == 5) {\n                log.info \"[执行breakLoop]\"\n                LoopUtils.breakLoop()  // 直接调用方法，无需return或throw\n            }\n        })\n        \n        // 示例2: for循环中使用continueLoop()方法 - 无需return或throw\n        log.info \"[2. for循环中使用continueLoop()]:\"\n        LoopUtils.forLoop(0, 10, 1, { int i ->\n            if (i % 2 == 0) {\n                log.info \"跳过偶数: $i\"\n                LoopUtils.continueLoop()  // 直接调用方法，无需return或throw\n            }\n            log.info \" 处理奇数: $i\"\n        })\n        \n        // 2. 带步长的for循环示例\n        log.info \"[2. 带步长的for循环示例 (0到20，步长为2)]：\"\n        LoopUtils.forLoop(0, 20, 2) { i ->\n            log.info \"$i \"\n        }\n        \n        // 示例: while循环中使用breakLoop()和continueLoop()\n        log.info \"[while循环中使用breakLoop()和continueLoop()]:\"\n        def count = 0\n        LoopUtils.whileLoop({ count < 10 }, {\n            count++\n            log.info \"While循环: $count\"\n            \n            if (count % 3 == 0) {\n                log.info \"跳过能被3整除的数: $count\"\n                LoopUtils.continueLoop()\n            }\n            \n            if (count == 7) {\n                log.info \"执行breakLoop\"\n                LoopUtils.breakLoop()\n            }\n        })\n        \n        \n    }\n\n}\n",
        "updateTime": 1766979096689,
        "bindingObjectApiName": "NONE",
        "type": "class",
        "nameSpace": "library",
        "tenantId": "67000207",
        "lang": 0
      },
      {
        "name": "HttpsService",
        "apiName": "HttpsService__c",
        "content": "/**\n * @author 彭黄振Jame\n * @codeName HttpsService\n * @description 公共callout service\n * @createTime 2025-10-11\n * @bindingObjectLabel --\n * @bindingObjectApiName NONE\n * @函数需求编号\n */\n\n\n/**\n * @type classes\n * @returntype\n * @namespace library\n */\nclass HttpsService {\n  \n    /**\n     * 统一 POST 发送 JSON（Adobe 协议创建场景）\n     * @param url        完整地址\n     * @param bearerKey  Bearer token\n     * @param bodyMap    请求体 Map（会被 StringBody 包装）\n     * @return [error, HttpResult, message] 三元组\n     */\n    static def postJson(String url, String bearerKey, Map bodyMap) {\n        StringBody body = StringBody.builder().content(bodyMap).build()\n        Request req = Request.builder()\n                             .method(\"POST\")\n                             .url(url)\n                             .timeout(75_000)\n                             .retryCount(0)\n                             .header(\"Content-Type\", \"application/json; charset=UTF-8\")\n                             .header(\"Authorization\", \"Bearer \" + bearerKey)\n                             .body(body)\n                             .build()\n        return http.execute(req)   // 返回三元组\n    }\n    \n    static def getWithBearer(String fullUrl, String bearerKey) {\n        Map headers = [\n            \"Accept\"        : \"application/json\",\n            \"Authorization\" : \"Bearer \" + bearerKey\n        ]\n        def (Boolean error, HttpResult result, String errorMsg) =\n                Fx.http.get(fullUrl, headers, 10_000, false, 0)\n        return [error, result, errorMsg]\n    }\n    \n    static def getFileWithBearer(String fullUrl, String bearerKey) {\n        Map headers = [\n            \"Content-Type\"        : \"application/pdf\",\n            \"Authorization\" : \"Bearer \" + bearerKey\n        ]\n        def (Boolean error, HttpResult result, String errorMsg) =\n                Fx.http.get(fullUrl, headers, 10_000, false, 0)\n        return [error, result, errorMsg]\n    }\n    \n    /**\n     * 统一上传 multipart/form-data（Adobe transientDocuments 场景）\n     * @param url        完整地址\n     * @param bearerKey  Bearer token\n     * @param fileName   文件名（不带后缀）\n     * @param inputStream 文件流\n     * @return [error, HttpResult, message] 三元组\n     */\n    static def postMultipart(String url,\n                             String bearerKey,\n                             String fileName,\n                             InputStream inputStream) {\n    \n        def multi = MultipartBody.builder()\n                                 .addPart(\"FileName\", fileName)\n        multi.addPart(\"File\", inputStream, fileName + '.pdf', 'application/pdf')\n        def finalMulti = multi.build()\n    \n        Request req = Request.builder()\n                             .method(\"POST\")\n                             .url(url)\n                             .timeout(70_000)\n                             .retryCount(0)\n                             .header(\"Content-Type\", \"multipart/form-data\")\n                             .header(\"accept\", \"application/json\")\n                             .header(\"Authorization\", \"Bearer \" + bearerKey)\n                             .body(finalMulti)\n                             .build()\n    \n        return http.execute(req)   // 依旧是三元组\n    }\n    \n    /**\n     * 统一上传 multipart/form-data; boundary=boundary123（Docusign transientDocuments 场景）\n     * @param url        完整地址\n     * @param bearerKey  Bearer token\n     * @param fileName   文件名（不带后缀）\n     * @param inputStream 文件流\n     * @return [error, HttpResult, message] 三元组\n     */\n    static def postDocsignMultipart(String url,\n                             String bearerKey,\n                             String fileName,\n                             InputStream inputStream,Map envelopeJson) {\n                               \n        def envStr = json.toJson(envelopeJson)\n        \n        def jsonPart = Strings.toUTF8Bytes(envStr)\n                               \n        def multi = MultipartBody.builder()\n        // JSON 部分\n        .addPart(\"form-data; name=\\\"envelopeDefinition\\\"\", jsonPart, \"request.json\", \"application/json\")\n        // PDF 文件部分\n        .addPart(\"file; filename=\\\"${fileName}\\\"; documentid=1\", inputStream, \"${fileName}\", \"application/pdf\")\n\n        def finalMulti = multi.build()\n    \n        // 3️⃣ 构建 HTTP 请求\n        def req = Request.builder()\n            .method(\"POST\")\n            .url(url)\n            .timeout(80_000)\n            .retryCount(0)\n            .header(\"Content-Type\", \"multipart/form-data; boundary=boundary123\")\n            .header(\"Accept\", \"application/json\")\n            .header(\"Authorization\", \"Bearer ${bearerKey}\")\n            .body(finalMulti)\n            .build()\n    \n        return http.execute(req)   // 依旧是三元组\n    }\n\n    //对外提供的方法\n    static String action() {\n        return \"sucesss\"\n    }\n\n    //debug 时候的入口方法\n    static void main(String[] args) {\n        String ret = action();\n        log.info(ret)\n    }\n\n}\n",
        "updateTime": 1766979094188,
        "bindingObjectApiName": "NONE",
        "type": "class",
        "nameSpace": "library",
        "tenantId": "67000207",
        "lang": 0
      },
      {
        "name": "ESignReceivedService",
        "apiName": "ESignReceivedService__c",
        "content": "/**\n * @author 彭黄振Jame\n * @codeName ESign Received Service\n * @description ESign Received Service\n * @createTime 2025-10-17\n * @bindingObjectLabel --\n * @bindingObjectApiName NONE\n * @函数需求编号\n */\n\n\n/**\n * @type classes\n * @returntype\n * @namespace library\n */\nclass ESignReceivedService {\n    static Map getESignReceived(String repsBody){\n        def body = Fx.json.parse(repsBody) \n        log.info(\"I am here\")\n        def eventResourceType = body.eventResourceType //用于判断是否来自于“agreement”的事件请求\n        def event = body.event //用于判断是否完成\n        def participantRole = body.participantRole as String//签署人角色\n        def actingUserEmail = body.actingUserEmail as String//签署人邮箱\n        def agreement = body.agreement as Map \n        \n        String agreementId = agreement.id //用于找到主表记录进行更新\n        String agreeStatus = agreement.status as String \n        String apiName = \"ESign_Record__c\"\n        \n        if(eventResourceType == \"agreement\" &&\n           participantRole == \"SIGNER\" &&\n           event ==\"AGREEMENT_ACTION_COMPLETED\") {//全部签署完成\n           Map updateData = Maps.newHashMap();\n           \n           if(agreeStatus == \"SIGNED\"){\n             updateData.put(\"sign_status__c\", \"COMPLETED\");\n           }\n            \n           def (Boolean error, QueryResult data, String errorMessage) = Fx.object.find(apiName, //对象apiName\n                                                                            FQLAttribute.builder()\n                                                                                    .columns([\"_id\", \"name\"]) //需要返回的字段\n                                                                                    .queryTemplate(QueryTemplate.AND([\"agreementId__c\": QueryOperator.EQ(agreementId)])) //查询条件\n                                                                                    .build(),\n                                                                           SelectAttribute.builder()\n                                                                                    .needCalculate(true) //是否实时处理计算字段，默认true\n                                                                                    .needQuote(true) //是否实时处理引用字段，默认true\n                                                                                    .calculateCount(true) //是否实时处理统计字段，默认true\n                                                                                    .fillExtendInfo(false) //是否补充字段扩展信息，比如查找关联字段的主属性、人员部门名称等，以${字段apiName}__r返回，默认false\n                                                                                    .needOptionLabel(false) //是否返回单选、多选字段的label，以${字段apiName}__r返回，默认false\n                                                                                    .convertQuoteForView(false) //引用字段是否返回label，如果为true，引用字段的value通过${字段apiName}__v返回，默认false\n                                                                                    .needInvalid(false) //是否返回已作废的数据，默认false\n                                                                                    .needRelevantTeam(false) //是否返回相关团队，默认false\n                                                                                    .build())\n            if (error) {\n                log.error(\"获取对象异常\" + errorMessage)\n            \n            } else {\n                log.info(\"I am here1\")\n                def dataList = data.dataList as List\n                String keyId = \"\"\n                dataList.each {\n                    e ->\n                        //dosomething，将示例逻辑细化至业务数据层\n                        def map = e as Map\n                        keyId = map['_id'] as String\n                }\n                def (Boolean err, Map reslt, String errMessage) =  Fx.object.update(apiName, keyId, updateData, UpdateAttribute.builder().triggerWorkflow(true).build())\n                log.info(\"I am here2\")\n                if (err) {\n                    log.error(\"获取对象异常\" + errMessage)\n                }\n                else {\n                    log.info(\"update data is : $reslt\")\n                    collectSigners(actingUserEmail, keyId, agreement)\n                }\n\n            }\n\n        } \n      \n        return body\n    }\n    \n    static Map collectSigners(String emailStr,String parentId,Map agreeMap) {\n        String userAPIName = \"ContactObj\"\n        def (Boolean error, QueryResult data, String errorMessage) = Fx.object.find(userAPIName, //对象apiName\n                                                                          FQLAttribute.builder()\n                                                                                    .columns([\"_id\", \"name\",\"email\"]) //需要返回的字段\n                                                                                    .queryTemplate(QueryTemplate.AND([\"email\": QueryOperator.EQ(emailStr)])) //查询条件\n                                                                                    .build(),\n                                                                          SelectAttribute.builder()\n                                                                                    .needCalculate(true) //是否实时处理计算字段，默认true\n                                                                                    .needQuote(true) //是否实时处理引用字段，默认true\n                                                                                    .calculateCount(true) //是否实时处理统计字段，默认true\n                                                                                    .fillExtendInfo(false) //是否补充字段扩展信息，比如查找关联字段的主属性、人员部门名称等，以${字段apiName}__r返回，默认false\n                                                                                    .needOptionLabel(false) //是否返回单选、多选字段的label，以${字段apiName}__r返回，默认false\n                                                                                    .convertQuoteForView(false) //引用字段是否返回label，如果为true，引用字段的value通过${字段apiName}__v返回，默认false\n                                                                                    .needInvalid(false) //是否返回已作废的数据，默认false\n                                                                                    .needRelevantTeam(false) //是否返回相关团队，默认false\n                                                                                    .build())\n         if (error) {\n                log.error(\"获取对象异常\" + errorMessage)\n                return\n            } else {\n                log.info(\"I am here5\")\n                def dataList = data.dataList as List\n                String contactId = \"\"\n                dataList.each {\n                    e ->\n                        //dosomething，将示例逻辑细化至业务数据层\n                        def map = e as Map\n                        contactId = map['_id'] as String\n                }\n                // def contactId = map['_id'] as String\n                log.info(\"I am here6\")\n                Map mainData = Maps.newHashMap();\n                mainData.put(\"esignRec__c\", parentId);\n                mainData.put(\"sign_status__c\", agreeMap.status);\n                mainData.put(\"signer__c\", contactId);\n                Map detailData = [:];\n                def (Boolean error1, Map data1, String errorMessage1) = Fx.object.create(\"ESign_Report_Record__c\", mainData, detailData, CreateAttribute.builder().build())\n                \n                if (error1) {\n                    log.error(\"获取对象异常error1\" + errorMessage1)\n                    return\n                }\n                else {\n                    log.info(\"create mainData is : $data1\")\n                }\n                return data1\n            }\n    }\n    \n    //对外提供的方法\n    static String action() {\n        return \"sucesss\"\n    }\n\n    //debug 时候的入口方法\n    static void main(String[] args) {\n        \n        log.info(action()) \n\n    }\n\n}\n",
        "updateTime": 1766979091658,
        "bindingObjectApiName": "NONE",
        "type": "class",
        "nameSpace": "library",
        "tenantId": "67000207",
        "lang": 0
      },
      {
        "name": "ESignInfo",
        "apiName": "ESignInfo__c",
        "content": "/**\n * @author 彭黄振Jame\n * @codeName ESignInfo\n * @description fetch ESign configuration\n * @createTime 2025-10-11\n * @bindingObjectLabel --\n * @bindingObjectApiName NONE\n * @函数需求编号\n */\n\n\n/**\n * @type classes\n * @returntype\n * @namespace library\n */\nclass ESignInfo {\n     /* 1. 外部可写的查询条件 */\n  public static String configName = 'Adobe Sign';\n  \n  // 缓存配置\n  // 2. 缓存：初始化为空 Map，避免 null\n  private static Map config = [:]\n\n  // 私有方法：加载配置\n  private static synchronized Map loadConfig() {\n    // 已经加载过（即使是空配置）就直接返回\n        if (config) return config\n        \n        def (Boolean error1, QueryResult queryResult, String errorMessage1) = Fx.object.find(\n          'ESignConfig__c',\n          FQLAttribute.builder()\n            .columns([\"_id\", \"name\", \"BaseUrl__c\", \"ClientID__c\", \"Securitykey__c\",\"isActive__c\",\"pem__c\",\"accountId__c\",\"auth_url__c\",\"userId__c\"])\n            .queryTemplate(\n              QueryTemplate.AND(\n                [\"name\": QueryOperator.EQ(configName)], [\"isActive__c\": QueryOperator.EQ(true)]\n              )\n            )\n            .build(),\n          SelectAttribute.builder()\n                  .needCalculate(true) //是否实时处理计算字段，默认true\n                  .needQuote(true) //是否实时处理引用字段，默认true\n                  .calculateCount(true) //是否实时处理统计字段，默认true\n                  .fillExtendInfo(false) //是否补充字段扩展信息，比如查找关联字段的主属性、人员部门名称等，以${字段apiName}__r返回，默认false\n                  .needOptionLabel(false) //是否返回单选、多选字段的label，以${字段apiName}__r返回，默认false\n                  .convertQuoteForView(false) //引用字段是否返回label，如果为true，引用字段的value通过${字段apiName}__v返回，默认false\n                  .needInvalid(false) //是否返回已作废的数据，默认false\n                  .needRelevantTeam(false) //是否返回相关团队，默认false\n                  .searchRichTextExtra(true)\n                  .build()\n        )\n  \n        if (error1) {\n          log.error(\"获取对象异常\" + errorMessage1)\n          config = [\n            signBaseURL: \"\",\n            baseURL    : \"\",\n            authURL    : \"\",\n            clientId    : \"\",\n            userId      : \"\",\n            accountId   : \"\",\n            key        : \"\",\n            pemKey     :\"\",\n            error: \"didnot find data\"\n          ]\n          log.info(config);\n          \n          return config\n        } else {\n          def dataList = queryResult.dataList as List //数据列表\n          def total = queryResult.total //符合条件的数据总条数\n          def size = queryResult.size  //本次返回的数据条数\n          dataList.each {\n                e ->\n                    //dosomething，将示例逻辑细化至业务数据层\n                    def map = e as Map\n                    \n                    config = [\n                      baseURL    : map[\"BaseUrl__c\"],\n                      authURL    : map[\"auth_url__c\"],\n                      clientId   : map[\"ClientID__c\"],\n                      userId     : map[\"userId__c\"],\n                      accountId  : map[\"accountId__c\"],\n                      key        : map[\"Securitykey__c\"],\n                      pemKey     : map[\"pem__c\"],\n                      error: \"\"\n                    ]\n                    log.info \"config:${config.baseURL}\"\n              \n            } \n          return config\n        }\n    \n  }\n\n    // 对外暴露的静态方法\n    static String getBaseURL()     { return loadConfig().baseURL }\n    static String getAuthURL()     { return loadConfig().authURL }\n    static String getClientId()     { return loadConfig().clientId }\n    static String getAccountId()     { return loadConfig().accountId }\n    static String getUserId()     { return loadConfig().userId }\n    static String getKey()         { return loadConfig().key }\n    static String getpemKey()         { return loadConfig().pemKey }\n    //对外提供的方法\n    static String action() {\n        return \"sucesss\"\n    }\n\n    //debug 时候的入口方法\n    static void main(String[] args) {\n        ESignInfo.configName = 'Adobe Sign'\n        log.info(\"baseURL: ${ESignInfo.getBaseURL()}\") \n        log.info(\"baseURL: ${ESignInfo.getClientId()}\")\n        log.info(\"key: ${ESignInfo.getKey()}\")\n    }\n\n}",
        "updateTime": 1766979089157,
        "bindingObjectApiName": "NONE",
        "type": "class",
        "nameSpace": "library",
        "tenantId": "67000207",
        "lang": 0
      },
      {
        "name": "ESTransientDocService",
        "apiName": "ESTransientDocService__c",
        "content": "/**\n * @author 彭黄振Jame\n * @codeName TransientDocService\n * @description 上传文件到 Adobe Sign 拿到 transientDocumentId\n * @createTime 2025-10-11\n * @bindingObjectLabel --\n * @bindingObjectApiName NONE\n * @函数需求编号\n */\n\n\n/**\n * @type classes\n * @returntype\n * @namespace library\n */\nclass ESTransientDocService {\n    /**\n     * 上传文件到 Adobe Sign 拿到 transientDocumentId\n     * @param baseUrl  Adobe 根地址\n     * @param key      Bearer token\n     * @param filePath 文件在 FX 中的完整路径（serviceReport[0].path）\n     * @param nPath    文件名（带后缀，例如 \"test\" -> 实际用 \"test.pdf\"）\n     * @return  transientDocumentId 或 null\n     */\n    static String uploadAndGetTransientId(String baseUrl,\n                                          String key,\n                                          String filePath,\n                                          String nPath,\n                                          String uri) {\n\n        InputStream inputStream = Fx.file.downloadStream(filePath)[1]['inputStream'] as InputStream\n\n        String url = baseUrl + uri\n        // 一行搞定\n        List ret = HttpsService.postMultipart(url, key, nPath, inputStream) as List\n        Boolean error = ret[0] as Boolean\n        HttpResult result = ret[1] as HttpResult\n        String message = ret[2] as String\n    \n        if (error) {\n            log.info(\"TransientDocService error: \" + message)\n            return null\n        }\n        \n\n        Map jsonMap = Fx.json.parse(result[\"content\"] as String)\n        return jsonMap[\"transientDocumentId\"] as String\n    }\n    \n    /**\n     * 上传文件到 Docusign 拿到 transientDocumentId\n     * @param baseUrl  Adobe 根地址\n     * @param key      Bearer token\n     * @param filePath 文件在 FX 中的完整路径（serviceReport[0].path）\n     * @param nPath    文件名（带后缀，例如 \"test\" -> 实际用 \"test.pdf\"）\n     * @return  transientDocumentId 或 null\n     */\n    static String uploadAndGetDocusignTransientId(String baseUrl,\n                                          String key,\n                                          String filePath,\n                                          String nPath,\n                                          String uri,\n                                          Map envelopeJson) {\n\n        InputStream inputStream = Fx.file.downloadStream(filePath)[1]['inputStream'] as InputStream\n\n        String url = baseUrl + uri\n        // 一行搞定\n        List ret = HttpsService.postDocsignMultipart(url, key, nPath, inputStream,envelopeJson) as List\n        Boolean error = ret[0] as Boolean\n        HttpResult result = ret[1] as HttpResult\n        String message = ret[2] as String\n    \n        if (error) {\n            log.info(\"TransientDocService error: \" + message)\n            return null\n        }\n        \n        log.info \"TransientDocService result: $result\"\n        Map jsonMap = Fx.json.parse(result[\"content\"] as String)\n        return jsonMap[\"envelopeId\"] as String\n    }\n    //对外提供的方法\n    static String action() {\n        return \"sucesss\"\n    }\n\n    //debug 时候的入口方法\n    static void main(String[] args) {\n        String ret = action();\n        log.info(ret)\n    }\n\n}",
        "updateTime": 1766979086578,
        "bindingObjectApiName": "NONE",
        "type": "class",
        "nameSpace": "library",
        "tenantId": "67000207",
        "lang": 0
      },
      {
        "name": "ESAgreementService",
        "apiName": "ESAgreementService__c",
        "content": "/**\n * @author 彭黄振Jame\n * @codeName ESAgreementService\n * @description 提交Agreement服务\n * @createTime 2025-10-11\n * @bindingObjectLabel --\n * @bindingObjectApiName NONE\n * @函数需求编号\n */\n\n\n/**\n * @type classes\n * @returntype\n * @namespace library\n */\n\n\nclass ESAgreementService {\n/**\n     * 创建 Adobe Sign 协议\n     * @param signName       协议名称\n     * @param baseUrl        Adobe 根地址\n     * @param key            Bearer token\n     * @param transientId    上一步拿到的 transientDocumentId\n     * @param innerMail      内部员工邮箱\n     * @param innerName      内部员工姓名\n     * @param participantOuterSetsInfoList   外部联系人信息\n     * @return  agreementId 或 null\n     */\n    static String createAgreement(String signName,\n                                  String baseUrl,\n                                  String key,\n                                  String uri,\n                                  String transientId,\n                                  String innerMail,\n                                  String innerName,\n                                  List participantOuterSetsInfoList) {\n\n        // 1. 协议头\n        Map agreeMap = [\n            name          : signName,\n            signatureType : \"ESIGN\",\n            state         : \"IN_PROCESS\",\n            fileInfos     : [[transientDocumentId: transientId]]\n        ]\n\n        // 2. 内部签署人\n        List participantSetsInfoList = []\n        participantSetsInfoList << [\n            order       : \"1\",\n            role        : \"SIGNER\",\n            name        : innerName,\n            memberInfos : [[email: innerMail]]\n        ]\n\n        participantSetsInfoList.addAll(participantOuterSetsInfoList);\n        agreeMap[\"participantSetsInfo\"] = participantSetsInfoList\n        String url = baseUrl + uri;//\"/api/rest/v6/agreements\"\n        // --- 改成 List 接收，避开解构 ---\n        List postRet = HttpsService.postJson(url, key, agreeMap) as List\n        Boolean err       = postRet[0] as Boolean\n        HttpResult res    = postRet[1] as HttpResult\n        String msg        = postRet[2] as String\n        if (err) {\n            log.info(\"AgreementService error: \" + msg)\n            return null\n        }\n        Map jsonMap = Fx.json.parse(res[\"content\"] as String)\n        return jsonMap[\"id\"] as String\n    }\n    \n    //docusign 专属获得去签名的url\n    static String getDocusignAgreementURL(String baseUrl,String key, String uri, Map bodyMap){\n      String url = baseUrl+uri\n      log.info('url:'+url)\n      log.info \"body is : $bodyMap\"\n      StringBody body = StringBody.builder().content(bodyMap).build()\n      Request req = Request.builder()\n                           .method(\"POST\")\n                           .url(url)\n                           .timeout(75_000)\n                           .retryCount(0)\n                           .header(\"Content-Type\", \"application/json\")\n                           .header(\"Accept\", \"application/json\")\n                           .header(\"Authorization\", \"Bearer \" + key)\n                           .body(body)\n                           .build()\n                           \n      def(Boolean error, HttpResult result, String message) =Fx.http.execute(req)\n\n      if (error) {\n          log.error(\"http request error: \"+ error +\" errorMessage: \" + message + \" result: \" + result)\n          return null\n      }\n      \n      \n      String contentMap = result.content as String\n      Map xmap = Fx.json.parse(contentMap)\n      def tmpurl = xmap['url']\n      log.info \"url:$tmpurl\"\n      return tmpurl as String\n    }\n    \n    //Adobe 专属获得去签名的url\n    static String getAgreementURL(String baseUrl,\n                                  String key,\n                                  String uri,\n                                  String agreementId\n                                  ){\n      String url = baseUrl + uri + agreementId + \"/signingUrls\"\n      log.info('url:'+url)\n      // --- 同样改成 List 接收 ---\n      List getRet = HttpsService.getWithBearer(url, key) as List\n      Boolean error        = getRet[0] as Boolean\n      HttpResult fileResult = getRet[1] as HttpResult\n      String errorMessage   = getRet[2] as String\n\n      if (error) {\n          Fx.log.info(\"http 请求出错 ： \" + errorMessage)\n          return null\n      }\n      if (fileResult.statusCode != 200) {\n          Fx.log.info(\"http 响应错误 ：\" + fileResult.content)\n          return null\n      }\n      \n     \n      Map contentMap = fileResult[\"content\"] as Map\n      \n      List signingUrlSetInfoList = contentMap[\"signingUrlSetInfos\"] as List\n      \n      Map signingUrlsMap = signingUrlSetInfoList[0] as Map \n      \n      List signingUrlsList = signingUrlsMap[\"signingUrls\"] as List\n      \n      Map esignUrlMap = signingUrlsList[0] as Map\n      \n      return esignUrlMap[\"esignUrl\"] as String\n    }\n    \n    //获取签署完毕的URL\n    static String getAgreementSignedFileURL(\n                                            String baseUrl,\n                                            String key,\n                                            String uri,\n                                            String agreementId\n                                            ){\n                                              \n      String url = baseUrl + uri + agreementId + \"/combinedDocument/url\"\n      log.info('url:'+url)\n      \n      // --- 同样改成 List 接收 ---\n      List getRet = HttpsService.getWithBearer(url, key) as List\n      Boolean error        = getRet[0] as Boolean\n      HttpResult fileResult = getRet[1] as HttpResult\n      String errorMessage   = getRet[2] as String\n      if (error) {\n          Fx.log.info(\"http 请求出错 ： \" + errorMessage)\n          return null\n      }\n      if (fileResult.statusCode != 200) {\n          Fx.log.info(\"http 响应错误 ：\" + fileResult.content)\n          return null\n      }\n      \n      Map fileUrl = fileResult[\"content\"] as Map\n      \n      log.info(fileUrl)\n      \n      return fileUrl.url as String\n                                              \n    }\n    \n    //获取签署完毕的Docusign流文件\n    static Map getAgreementDocuSignedFileURL(\n                                            String baseUrl,\n                                            String key,\n                                            String uri,\n                                            String agreementId\n                                            ){\n                                              \n      String url = baseUrl + uri + \"/envelopes/\"+agreementId+\"/documents/combined\"\n      log.info('url:'+url)\n      \n      // Map map = [\"id\": agreementId, \"name\": \"协议\"]\n      // StringBody body = StringBody.builder().content(map).build()\n      \n      Request request = Request.builder()\n                        .method(\"GET\")\n                        .url(url)\n                        .timeout(7000)\n                        .retryCount(0)\n                        .header(\"Authorization\", \"Bearer \"+key)\n                        .header(\"Content-Type\", \"application/json\")\n                        .build()\n      def res = Fx.file.uploadFileByStream(request)\n      log.info(res)\n      \n      return res as Map\n                                              \n    }\n    \n    //获取签署完毕的Adobe流文件\n    static Map getAgreementAcrobatSignedFileURL(\n                                            String baseUrl,\n                                            String key,\n                                            String uri,\n                                            String agreementId\n                                            ){\n                                              \n      String url = baseUrl + uri + \"/agreements/\"+agreementId+\"/combinedDocument\"\n      log.info('url:'+url)\n      \n      Request request = Request.builder()\n                        .method(\"GET\")\n                        .url(url)\n                        .timeout(7000)\n                        .retryCount(0)\n                        .header(\"Authorization\", \"Bearer \"+key)\n                        .header(\"Accept\", \"application/pdf\")\n                        .build()\n      def res = Fx.file.uploadFileByStream(request)\n      log.info(res)\n      \n      return res as Map\n                                              \n    }\n    //对外提供的方法\n    static String action() {\n        return \"sucesss\"\n    }\n    \n    //debug 时候的入口方法\n    static void main(String[] args) {\n        String ret = action();\n        log.info(ret)\n    }\n\n}\n",
        "updateTime": 1766979084133,
        "bindingObjectApiName": "NONE",
        "type": "class",
        "nameSpace": "library",
        "tenantId": "67000207",
        "lang": 0
      },
      {
        "name": "DocuSignAuth",
        "apiName": "DocuSignAuth__c",
        "content": "/**\n * @author 彭黄振Jame\n * @codeName DocuSignAuth\n * @description DocuSignAuth\n * @createTime 2025-10-28\n * @bindingObjectLabel --\n * @bindingObjectApiName NONE adb\n * @函数需求编号\n */\nimport fx.custom.apl.jar.JWTUtils\n\n\n/**\n * @type classes\n * @returntype\n * @namespace library aa\n */\nclass DocuSignAuth {\n  \n    // 设置 DocuSign 配置名称\n    private static String configName = 'Docusign'\n    private static Boolean refreshToken = false\n    \n    // 使用 ESignInfo 获取配置值\n    private static String getIss() { \n        String originalConfigName = ESignInfo.configName\n        ESignInfo.configName = configName\n        String clientId = ESignInfo.getClientId()\n        ESignInfo.configName = originalConfigName\n        return clientId\n    }\n    \n    private static String getSub() { \n        String originalConfigName = ESignInfo.configName\n        ESignInfo.configName = configName\n        String userId = ESignInfo.getUserId()\n        ESignInfo.configName = originalConfigName\n        return userId\n    }\n    \n    private static String getAud() { \n        String originalConfigName = ESignInfo.configName\n        ESignInfo.configName = configName\n        String authUrl = ESignInfo.getAuthURL()\n        ESignInfo.configName = originalConfigName\n        return authUrl\n    }\n    \n    private static String getScope() { \n        return \"signature impersonation\"\n    }\n    \n    private static String getAlg() { \n        return \"RS256\" \n    }\n    \n    private static String getCacheKey() { \n        return \"DocuSign_token\" \n    }\n    \n    private static String getDocusignAuthUrl() {\n        String audUrl = getAud()\n        log.info \"audUrl:${audUrl}/oauth/token\"\n        return \"${audUrl}/oauth/token\"\n    }\n    \n    // 获取私钥的方法\n    private static String getKeyPem() {\n        String originalConfigName = ESignInfo.configName\n        ESignInfo.configName = configName\n        String pemKey = ESignInfo.getpemKey()\n        ESignInfo.configName = originalConfigName\n        return pemKey\n    }\n  \n    // private static String iss = \"a305ecce-a390-422c-96f0-52d5e1cbd158\"\n    // private static String sub = \"f0d94e7b-946f-4ef6-841d-e945ee2b93d9\"\n    // private static String aud = \"account-d.docusign.com\"\n    // private static String scope = \"signature impersonation\"\n    // private static String alg = \"RS256\"\n    // private static String cacheKey = \"DocuSign_token\"\n    \n    // private static String docusignAuthUrl =\"https://\"+aud+\"/oauth/token\"\n    /**\n     * 无循环，顺序无关，保留换行\n     * 返回 Map[\"PUBLIC\":\"...\",\"PRIVATE\":\"...\"]\n     */\n    static Map<String, String> splitPem(String pem) {\n        Map<String, String> ans = new LinkedHashMap<String, String>()\n        if (pem == null) return ans\n    \n        /* 两个独立前瞻，各抓各的块，顺序任意 */\n        String regex = '(?s)(?=.*-----BEGIN PUBLIC KEY-----(.*?)-----END PUBLIC KEY-----)' +\n                       '(?=.*-----BEGIN RSA PRIVATE KEY-----(.*?)-----END RSA PRIVATE KEY-----)'\n        def m = pem =~ regex\n    \n        if (m.find()) {\n            ans.put('PUBLIC',\n                    '-----BEGIN PUBLIC KEY-----' + m.group(1) + '-----END PUBLIC KEY-----')\n            ans.put('PRIVATE',\n                    '-----BEGIN RSA PRIVATE KEY-----' + m.group(2) + '-----END RSA PRIVATE KEY-----')\n        }\n        return ans\n    }\n    \n    /**\n     * 向 DocuSign 账户服务器申请 JWT AccessToken\n     * @param privateKeyPem 完整的 RSA 私钥 PEM（含 -----BEGIN/END...）\n     * @return Map 成功返回 [\"access_token\":..., \"expires_in\":...]；失败返回 null\n     */\n    static String requestAccessToken(Map<String,Object> payload, String privateKeyPem, Integer expires, String alg) {\n        \n        def content\n        // 2. 生成 JWT\n        String token = JWTUtils.generateToken(payload, privateKeyPem, expires, alg)\n        if (token == null) {\n            log.error('JWT generate failed')\n            return null\n        }\n        log.info \"token:$token\"\n        // 3. 组装表单请求\n        FormBody body = FormBody.builder()\n                .field('grant_type', 'urn:ietf:params:oauth:grant-type:jwt-bearer')\n                .field('assertion', token)\n                .build()\n\n        Request request = Request.builder()\n                .method('POST')\n                .url(getDocusignAuthUrl())\n                .timeout(7000)\n                .retryCount(0)\n                .header('Content-Type', 'application/x-www-form-urlencoded')\n                .body(body)\n                .build()\n    \n        // 4. 执行请求\n        def(Boolean error, HttpResult result, String message) = Fx.http.execute(request)\n        if (error || result.statusCode != 200) {\n            //可以增加打印请求参数\n            log.error(\"http request error: \"+ error +\" errorMessage: \" + message + \" result: \" + result)\n\n        } else {\n          content = result.content as Map//函数封装的结果，一般使用这个即可\n          // log.info(\"result: \"+ result)\n          Integer expiresSecond = content[\"expires_in\"] as Integer\n          Long nowMillis = DateTime.now().toTimestamp()\n          if (nowMillis < 10_000_000_000L) nowMillis *= 1000\n          Long tokenExpireMillis = nowMillis + (expiresSecond - 30) * 1000\n          Map tokenMap = [:]\n          tokenMap.put(\"access_token\", content[\"access_token\"] as String)\n          tokenMap.put(\"token_type\", content[\"token_type\"] as String)\n          tokenMap.put(\"token_expires_millis\", tokenExpireMillis)\n          \n          Cache cache = Fx.cache.getDefaultCache()//将token放入本地缓存\n          String value = Fx.json.toJson(tokenMap)\n          cache.put(getCacheKey(), value, expiresSecond)\n          log.info(\"saveAccessToken2Cache key:\" + getCacheKey())\n        }\n        return content[\"access_token\"] as String\n    }\n    \n    static String getAccessToken(String privateKeyPem) {\n        Cache cache = Fx.cache.getDefaultCache()\n        log.info \"current cache :${cache}\"\n        String value = cache.get(getCacheKey()) as String//从本地缓存取出token\n        String accessToken = \"\"\n        if(refreshToken || value == null){\n            // log.info(\"getAccessTokenFromCache key:\" + getCacheKey() )\n            // log.info(\"value is null refreshToken:\" + refreshToken )\n            accessToken = getRefreshToken(privateKeyPem)\n            log.info(\"get New AccessToken for value null:\" +accessToken)\n            return accessToken\n        }\n        Map tokenMap = Fx.json.parse(value)\n        accessToken = tokenMap[\"access_token\"] as String\n        Long expired = tokenMap[\"token_expires_millis\"] as Long\n        log.info(\"getAccessTokenFromCache key:\" + accessToken)\n        \n        if(expired <= DateTime.now().toTimestamp()){\n            \n            accessToken = getRefreshToken(privateKeyPem)\n            log.info(\"get New AccessToken for expired:\" +accessToken)\n        }\n        \n  \n        return accessToken\n    }\n    \n    static String getRefreshToken (String privateKeyPem) {\n          Map<String, Object> payload = new LinkedHashMap<String, Object>()\n          payload.put('iss', getIss())        // Integrator Key\n          payload.put('sub', getSub())        // UserId\n          payload.put('aud', getAud().replace(\"https://\", \"\"))\n          payload.put('scope', getScope())\n          String accessToken = requestAccessToken(payload, privateKeyPem,6000,getAlg())\n          return accessToken\n    }\n    \n    static String getAccessToken() {\n      String keyStr = getKeyPem()\n      // log.info \"keyStr:$keyStr\"\n      Map<String, String> keys = splitPem(keyStr)\n      String privateKeyPem = keys.get('PRIVATE')\n      // log.info \"privateKeyPem:$privateKeyPem\"\n      return getAccessToken(privateKeyPem)\n    }\n    //对外提供的方法\n    static String action() {\n        return \"sucesss\"\n    }\n\n    //debug 时候的入口方法\n    static void main(String[] args) {\n      // refreshToken = true\n      String key = getAccessToken()\n      log.info \"Access Token key: $key\"\n\n      \n    }\n\n}",
        "updateTime": 1766979081651,
        "bindingObjectApiName": "NONE",
        "type": "class",
        "nameSpace": "library",
        "tenantId": "67000207",
        "lang": 0
      },
      {
        "name": "ClassUtils",
        "apiName": "ClassUtils__c",
        "content": "/**\n * @author 彭黄振Jame\n * @codeName ClassUtils\n * @description Class Utils\n * @createTime 2025-10-22\n * @bindingObjectLabel --\n * @bindingObjectApiName NONE\n * @函数需求编号\n */\n\n\n/**\n * @type classes\n * @returntype\n * @namespace library\n */\n@groovy.transform.CompileStatic\nclass ClassUtils {\n    \n    /** 静态编译：只负责拿到 Class */\n    static Class<?> classForName(String clsName) {\n\n        String targetName = 'fx.custom.apl.script.' + clsName\n        // 任意“已加载”的类当锚点\n        def anchorClass = this // 拿去当前类的基本属性\n        def cl = anchorClass.getClassLoader() // 不会触发 CPS 黑名单\n        def targetClass = cl.loadClass(targetName)//获取定义类\n        return targetClass as Class // 字段访问，安全\n    }\n    /** 动态编译：一次封装，处处可用 */\n    // @groovy.transform.CompileDynamic\n    static Object invokeStatic(String clsName, String methodName, Object... args) {\n        Class<?> clazz = classForName(clsName)\n        def util = ClassUtils.newInstance(clsName)\n        Class[] paramTypes = args.collect { it?.class } as Class[]\n        return clazz.getDeclaredMethod(methodName, paramTypes)\n                    .invoke(util, args)\n    }\n    \n    /* 下面这两个方法同样动态，调用者仍无需注解 */\n    static Object invoke(String clsName, String methodName, Object instance, Object... args) {\n        Class<?> clazz = classForName(clsName)\n        Class[] paramTypes = args.collect { it?.class } as Class[]\n        return clazz.getDeclaredMethod(methodName, paramTypes)\n                    .invoke(instance, args)\n    }\n    \n    /* 快速 new 实例 */\n    static Object newInstance(String clsName, Object... args) {\n        Class<?> clazz = classForName(clsName)\n        Class[] paramTypes = args.collect { it?.class } as Class[]\n        return clazz.getDeclaredConstructor(paramTypes)\n                    .newInstance(args)\n    }\n    \n    //对外提供的方法\n    static String action() {\n        return \"sucesss\"\n    }\n\n    //debug 时候的入口方法\n    static void main(String[] args) {\n        def id = ClassUtils.invokeStatic('ShortSnowflakeIdUtil', 'nextId')\n        log.info(id)\n        // 实例方法同理\n        def util = ClassUtils.newInstance('ShortSnowflakeIdUtil')\n        // log.info(util.getDeclaredMethod('nextId').invoke(null))\n        def id2  = ClassUtils.invoke('ShortSnowflakeIdUtil', 'nextId', util)\n        log.info(id2)\n    }\n\n}\n",
        "updateTime": 1766979079117,
        "bindingObjectApiName": "NONE",
        "type": "class",
        "nameSpace": "library",
        "tenantId": "67000207",
        "lang": 0
      },
      {
        "name": "CertTokenUtils",
        "apiName": "CertTokenUtils__c",
        "content": "/**\n * 证书令牌工具类\n * 功能：生成包含摘要、压缩原文、盐值和校验码的安全令牌\n * 令牌格式：12位摘要 + 14位压缩原文 + 6位盐 + 2位计数 + 8位校验码 = 42字符\n */\nclass CertTokenUtils {\n    // 计数器，用于生成唯一序列\n    private static int COUNTER = 0\n    \n    // 存储原始内容的映射，key为12位摘要，value为原始Base64字符串\n    private static Map<String, String> originalMap = new HashMap<>()\n\n    /**\n     * 1. 编码方法：生成42字符的安全令牌\n     * 令牌结构：12位摘要 + 14位压缩原文 + 6位时间盐 + 2位计数器 + 8位校验码\n     * @param rawBase64 原始Base64字符串\n     * @return 42字符的安全令牌\n     */\n    static String encode(String rawBase64) {\n        // ① 摘要计算：使用SHA-256生成哈希，取前12位36进制作为摘要标识\n        byte[] hash32 = java.security.MessageDigest.getInstance(\"SHA-256\").digest(rawBase64.getBytes())\n        String hash36 = bytesToHex(hash32)          // 将字节数组转换为十六进制字符串\n        String idx12  = hash36.substring(0, 12)     // 取前12位作为摘要标识\n    \n        // ② 压缩原文：将原始Base64编码并截取前14位，不足补'A'\n        String comp14 = java.util.Base64.getUrlEncoder()\n                                      .encodeToString(rawBase64.getBytes())  // Base64URL编码\n                                      .substring(0, Math.min(14, rawBase64.length()))  // 截取前14位\n                                      .padRight(14, 'A')        // 不足14位时右侧补'A'\n    \n        // ③ 盐值 + 校验码生成\n        String time = Long.toString(System.currentTimeMillis(), 36).substring(0, 6)  // 当前时间戳的36进制，取前6位\n        String cnt  = padTwo(Long.toString((nextCounter() & 0xFF), 36))              // 2位计数器，36进制\n        String salt = time + cnt                                                     // 组合成8位盐值(6位时间+2位计数)\n        \n        // 校验码计算：摘要与盐值异或后取低33位，转为8位36进制\n        long mix = Long.parseLong(idx12, 36) ^ Long.parseLong(salt, 36)              // 摘要与盐值异或\n        String check = padEight(Long.toString(mix & 0x1FFFFFFFFL, 36))               // 取低33位并补零到8位\n    \n        // 组合生成完整令牌：12位摘要 + 14位压缩原文 + 8位盐值 + 8位校验码 = 42字符\n        String token = idx12 + comp14 + salt + check\n        \n        // 存储原始内容到映射，后续解码时使用\n        originalMap.put(idx12, rawBase64)\n        \n        return token\n    }\n\n    /**\n     * 2. 解码方法：从令牌中还原原始Base64字符串\n     * 优先从内存映射中获取，映射不存在时降级到解码压缩版本\n     * @param token 42字符的安全令牌\n     * @return 原始Base64字符串，解码失败返回空字符串\n     */\n    static String decode(String token) {\n        // 基础校验：令牌长度必须至少42字符\n        if (token == null || token.length() < 42) {\n            return \"\"\n        }\n        \n        try {\n            // 提取令牌前12位作为摘要标识\n            String idx12 = token.substring(0, 12)\n            \n            // 优先从内存映射中获取原始内容（确保返回完整原始数据）\n            String original = originalMap.get(idx12)\n            if (original != null) {\n                return original\n            }\n            \n            // 降级方案：如果映射中不存在，解码压缩的Base64部分\n            // 注意：这可能返回被截断的内容，因为编码时只保留了前14位\n            String comp14 = token.substring(12, 26)  // 提取14位压缩原文\n            byte[] decodedBytes = java.util.Base64.getUrlDecoder().decode(comp14)  // Base64URL解码\n            return new String(decodedBytes)\n        } catch (Exception e) {\n            e.printStackTrace()\n            return \"\"\n        }\n    }\n\n    /**\n     * 3. 验证方法：校验令牌的完整性和真实性\n     * 通过重新计算校验码并与令牌中的校验码对比来验证\n     * @param token 42字符的安全令牌\n     * @return 验证通过返回true，否则返回false\n     */\n    static boolean verify(String token) {\n        try {\n            // 基础校验：令牌必须恰好42字符\n            if (token == null || token.length() != 42) {\n                return false\n            }\n            \n            // 提取令牌各组成部分\n            String idx12 = token.substring(0, 12)           // 前12位：摘要标识\n            String salt = token.substring(26, 34)           // 第27-34位：盐值(6位时间+2位计数)\n            String chk = token.substring(34, 42)            // 第35-42位：校验码\n            \n            // 重新计算校验码：使用相同的算法\n            long mix = Long.parseLong(idx12, 36) ^ Long.parseLong(salt, 36)      // 摘要与盐值异或\n            String calculatedCheck = padEight(Long.toString(mix & 0x1FFFFFFFFL, 36))  // 计算8位校验码\n            \n            // 比较计算出的校验码与令牌中的校验码是否一致\n            return calculatedCheck.equals(chk)\n        } catch (Exception e) { \n            e.printStackTrace()\n            return false \n        }\n    }\n\n    /**\n     * 清理方法：从内存映射中移除令牌对应的原始内容\n     * 防止内存泄漏，建议在使用完令牌后调用\n     * @param token 要清理的令牌\n     */\n    static void cleanup(String token) {\n        if (token != null && token.length() >= 12) {\n            originalMap.remove(token.substring(0, 12))  // 使用摘要标识作为key进行移除\n        }\n    }\n\n    /**\n     * 4. 对外接口方法\n     * @return 固定返回\"success\"字符串\n     */\n    static String action() { return \"success\" }\n\n    /* ====== 内部工具方法 ====== */\n    \n    /**\n     * 计数器递增方法\n     * 每次调用计数器加1，并限制在0xFFFFFF范围内\n     * @return 更新后的计数器值\n     */\n    private static int nextCounter() { return COUNTER = (COUNTER + 1) & 0xFFFFFF }\n\n    /**\n     * DJB哈希算法：递归实现的无循环哈希函数\n     * @param data 输入字节数组\n     * @param idx 当前处理索引\n     * @param h 当前哈希值\n     * @return 计算完成的哈希值\n     */\n    private static long djb(byte[] data, int idx, long h) {\n        return idx >= data.length ? h : djb(data, idx + 1, ((h << 5) + h + (data[idx] & 0xFF)) & 0x7FFFFFFFL)\n    }\n\n    /**\n     * 补零工具方法：确保字符串至少2位长度\n     * @param s 输入字符串\n     * @return 补零后的2位字符串\n     */\n    private static String padTwo(String s)  { return s.length() >= 2 ? s : \"0\" + s }\n    \n    /**\n     * 补零工具方法：确保字符串至少8位长度\n     * @param s 输入字符串\n     * @return 补零后的8位字符串\n     */\n    private static String padEight(String s){ return s.length() >= 8 ? s : String.format(\"%0\" + (8 - s.length()) + \"d%s\", 0, s) }\n\n    /* 5. 十六进制转换工具 */\n    \n    /**\n     * 字节数组转十六进制字符串\n     * 使用Stream API实现无循环转换\n     * @param bytes 输入字节数组\n     * @return 十六进制字符串\n     */\n    private static String bytesToHex(byte[] bytes) {\n        return java.util.stream.IntStream.range(0, bytes.length)\n                                  .mapToObj(new java.util.function.IntFunction<String>() {\n                                      @Override\n                                      String apply(int i) {\n                                          return byteToHex(bytes[i]);\n                                      }\n                                  })\n                                  .collect(java.util.stream.Collectors.joining());\n    }\n    \n    /**\n     * 单字节转十六进制字符串\n     * @param b 输入字节\n     * @return 2位十六进制字符串（大写）\n     */\n    private static String byteToHex(byte b) {\n        return Integer.toHexString(b & 0xFF).toUpperCase();\n    }\n\n    /**\n     * 6. 测试方法：验证编码、解码、验证功能的正确性\n     */\n    static void main(String[] args) {\n        // 测试用的长Base64字符串\n        String raw = 'ZXlKaGJHY2lPaUpJVXpJMU5pSXNJblI1Y0NJNklrcFhWQ0o5LmV5SnpkV0lpT2lKU1pYRjFaWE4wVkc5clpXNGlMQ0pwYzNNaU9pSkRSVkF0VTJWeWRtVnlJaXdpWlc1MFpYSndjbWx6WlVGalkyOTFiblFpT2lKbWEzUmxjM1E0TlRFNUlpd2laVzUwWlhKd2NtbHpaVWxrSWpvMk56QXdNREl3Tnl3aWMyVnpjMmx2Ymtsa0lqb2lOMlZsTVdKa01qWXRNalV6T1MwME16RTJMVGd6TURJdE5qZzNaakUzT1RBeU1EZzJJaXdpWlhod0lqb3pPRE0yTURBek1UZ3pMQ0oxYzJWeVNXUWlPakV3TURBc0ltbGhkQ0k2TVRjMk1ETXlNVEk1TW4wLjZUcDc0RF9hZlJRWTlZOVRQdFl5UUJXaWVDQ1lFaUtaWVNQUVp1d3dNR2M='\n        \n        // 编码测试\n        def t = encode(raw)\n        log.info(\"Token: \" + t)\n        \n        // 解码测试\n        log.info(\"Decoded: \" + decode(t))\n        \n        // 验证测试\n        log.info(\"Verify: \" + verify(t))\n        \n        // 清理测试\n        cleanup(t)\n    }\n}",
        "updateTime": 1766979076578,
        "bindingObjectApiName": "NONE",
        "type": "class",
        "nameSpace": "library",
        "tenantId": "67000207",
        "lang": 0
      },
      {
        "name": "AdobeWebhookController",
        "apiName": "AdobeWebhookController__c",
        "content": "/**\n * @author 彭黄振Jame\n * @codeName Adobe Webhook Controller\n * @description Adobe Webhook Controller\n * @createTime 2025-10-16\n * @bindingObjectLabel --\n * @bindingObjectApiName NONE\n * @函数需求编号\n */\n\n\n/**\n * @type classes\n * @returntype\n * @namespace library\n */\n/**\n * @author 彭黄振Jame\n * @codeName WebHookController\n * @description WebHookController\n * @createTime 2025-10-13\n * @bindingObjectLabel --\n * @bindingObjectApiName NONE\n * @函数需求编号\n */\n\n\n/**\n * @type classes\n * @returntype\n * @namespace apl_controller\n */\n@AplController(baseUrl = \"/apl\")\nclass AdobeWebhookController {\n    \n    @AplRequestMapping(value = \"/postmethod\", method = RequestMethod.POST)\n    public HttpResponse query(HttpRequest request) {\n        String requestBody = new String(request.getBody(), \"UTF-8\")\n        log.info(requestBody)\n        Map returnBody = ESignReceivedService.getESignReceived(requestBody) as Map\n        // Map returnBody = [\"status\": 200, \"data\": \"ook\", \"message\": \"success!\",\"xAdobeSignClientId\":\"UB7E5BXCXY\"]\n        String body = Fx.json.toJson(returnBody)\n        return HttpResponse.ok()\n                .header(\"Content-Type\", \"application/json\")\n                .header(\"x-adobesign-clientid\", \"UB7E5BXCXY\")\n                // .header(\"x-adobesign-clientid\", \"ats-1e6bdecd-7ca6-4e5f-9ef6-05068f29712d\")\n                .body(body)\n    }\n    \n    @AplRequestMapping(value = \"/getmethod\", method = RequestMethod.POST)\n    public HttpResponse getmethod(HttpRequest request) {\n        String requestBody = new String(request.getBody(), \"UTF-8\")\n        log.info(\"request body: \" + requestBody)\n        Map returnBody = [\"xAdobeSignClientId\":\"UB7E5BXCXY\",\"status\":200]\n        String body = Fx.json.toJson(returnBody)\n        return HttpResponse.ok()\n                .header(\"Content-Type\", \"application/json\")\n                .header(\"x-adobesign-clientid\", \"UB7E5BXCXY\")\n                .body(body)\n    }\n\n    /**\n     * 硬编码方法：获取AplRequestMapping路径映射\n     * @return Map<String, String> 方法名到路径的映射\n     */\n    public Map<String, String> getAplRequestMappingPaths() {\n        Map<String, String> pathMapping = [:]\n        \n        // 硬编码添加所有AplRequestMapping的路径\n        pathMapping.put(\"POST\", \"/apl/postmethod\")\n        pathMapping.put(\"GET\", \"/apl/getmethod\")\n        \n        return pathMapping\n    }\n\n    public void debug(FunctionContext context, Map<String, Object> args) {\n      \n        \n        Map headers = [\n                \"Content-Type\": [\"application/json\"]\n        ]\n        Map parameters = [\n                \"name\": [\"zhangsan\"]\n        ]\n        byte[] body = [1, 2, 3] as byte[]\n        HttpRequest request = new HttpRequest(headers, parameters, body)\n        def clz = ClassUtils.invokeStatic('AdobeWebhookController', 'postmethod',request)\n        // log.info(Fx.json.toJson(query(request)))\n        log.info(Fx.json.toJson(clz))\n        \n        // 测试获取路径映射\n        log.info(\"AplRequestMapping Paths: \" + Fx.json.toJson(getAplRequestMappingPaths()))\n        \n        // request = new HttpRequest(headers, parameters, body)\n        // log.info(\"====result: \" + Fx.json.toJson(getMethod(request)))\n    }\n}\n",
        "updateTime": 1766979073829,
        "bindingObjectApiName": "NONE",
        "type": "class",
        "nameSpace": "library",
        "tenantId": "67000207",
        "lang": 0
      }
    ]
  }
}